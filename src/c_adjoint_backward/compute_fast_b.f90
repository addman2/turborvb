!TL off
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.2 (r3024) - 06/17/2009 13:03
!  
!  Differentiation of compute_eloc_logpsi in reverse (adjoint) mode:
!   gradient, with respect to input variables: winvjbarsz logpsi
!                eloc winvup kelind rion iond ainv kel tmu tabpip
!                prefactor dist winvjbar winvdo
!   of linear combination of output variables: logpsi eloc
!  NB here yesfast and yesfastj coincide with global variables contraction and 
!  contractionj in the main, respectively (>0 if contracted orbitals are used).
SUBROUTINE COMPUTE_ELOC_LOGPSI_B(indt, nelorb, nelup, neldo, tabpip, &
        &  tabpipb, tabpipsav, kelind, kelindb, kel, kelb, winv, winvb, indt4, winvup, winvupb, winvdo, &
        &  winvdob, ainv, ainvb, ainvup, ainvupb, ainvdo, ainvdob, psip, psipb, ipsip, &
        &  psisn, iesdr, vj, vjb, dimvj, dd, ddb, dimdd, zeta, rion, rionb, dist, distb, &
        &  ioccup, ioccdo, ioptorb, nshell, nshelldo, ivic, ivicb, vpot, tmu, tmub, &
        &  nion, r, rb, rmu, rmub, kion, iond, iond_cartb, winvj, winvjb, indt4j, ioccj, kionj, &
        &  vju, vjub, dimvju, nelorbj, ioptorbj, nshellj, winvbar, winvbarb, detmat, detmatb,eagp_pfaffb&
        &, winvjbar, &
        &  winvjbarb, winvjbarsz, winvjbarszb, jasmat, jasmatb, muj_c, muj_cb, jasmat_c, jasmat_cb&
        &, jasmatsz, jasmatszb, jasmatsz_c, jasmatsz_cb, nelorbj_c, yesfastj, iessz&
        &, cnorm, iflag, &
        &  ncore, lmax, nintpseudo, prefactor, prefactorb, rcutoff, parshell, nparpshell, &
        &  kindion, pshell, wpseudo, wpseudob, legendre, legendreb, versor, wintpseudo &
        &, jpseudo, pseudolocal, istart, costz, costz3, angle, indtm, lbox, &
        &  rmucos, rmucosb, rmusin, rmusinb, oldkappa, vpotreg, cutreg, psidetln, walker, &
        &  nelorbh, nelorbjh, niesd, iond_cart, mu_c, mu_cb, detmat_c, detmat_cb&
        &, nelorb_c, firstmol, nmol, yesfast, yeszagp, yesdodet, yeszj, yesforce, eloc, elocb&
        &, logpsi, logpsib, nelorbjmax, neldomax&
        &, indtmax, nshelljmax, cellscaleb, s2rb, iflagnorm&
        &, indpar_tab, indorb_tab, indshell_tab, indparj_tab, indorbj_tab, indshellj_tab&
        &, adr_nion, ind_nion, adrj_nion, indj_nion, notest)
    USE EWALD
    USE CELL
    USE CONSTANTS
    use allio, only : ipj, yesupel, symmagp, yes_hermite, detc_proj, nelorb_at&
            &, yes_correct, pointvj, nel_mat, nelup_mat, ndim_detmat, ndiff, n_body_on, gamma, lrdmc_der, lrdmc_nonodes, alat, plat, iespbc, npar_eagp,timingsb&
    &,cutweight,true_wagner,npow,membigcpu,yes_sparse,nelorbjh2,nnozeroj,nozeroj,norm_metric
    IMPLICIT NONE
    !      nelorbjmax=max(nelorbj,1)
    !      neldomax=max(neldo,1)
    !      indtmax=max(indt,1)
    !      nshelljmax=max(nshellj,1)
    INTEGER :: nelup, neldo, nel, i, j, k, j1, j2, info, ispin, iesd, &
            &  iesdr, IESDR2IESD, nelorb, nelorbj, nion, kk, jj, nshell, &
            &  nshelldo, nelorbup, nelorbdo, indt, nelorb5, nelorbj5, iflagnorm, &
            &  iflag, ncore, lmax, istart, nintpseudo, walker, &
            &  firstmmu, nelorbh, nelorbjh, niesd, signold, nelorb_c, firstmol, nmol&
            &, yesfast, ind1, ind2, ind3, ind4, ind5, ind6, isdistp, ip5, sizework1&
            &, sizewsz, nelorbjmax, neldomax, indtmax, nshellj, nshelljmax&
            &, nshellh, nshelljh, nshelldoh, dimvj, dimdd, dimvju, nelup1, zerop1,dim_jasmat&
            &, nelcol, nelcol_c, nelorbjh2o, dimmuc, dimdetmat_c, indt4, indt4j, yesfastj&
            &, nelorbj_c, nelorbjc, nelorbjcp, nelorbj_c2, dimmujc, nelused, nelorbju, istartu,ix,iy

    INTEGER :: indpar_tab(*), indorb_tab(*), indshell_tab(*), indparj_tab(*)&
            &, indorbj_tab(*), indshellj_tab(*), adr_nion(*), ind_nion(*), adrj_nion(*)&
            &, indj_nion(*)
    INTEGER :: ioccup(*), ioccdo(*), ioptorb(*), ioptorbj(&
            &  *), kion(*), kionj(*), ioccj(*), &
            &  nparpshell(lmax, *), kindion(*), indtm(*), pshell(&
            &  *), jpseudo(lmax, *), ipsip(*)
    REAL*8 :: tabpip(nelup + neldo, *), tmu(nelup + neldo, *), psip(*), winv(ipc * nelorb, 0:indt4, *), winvj(nelorbjmax, 0:indt4j, &
            &  *), winvup(ipc * nelup, *), winvdo(max(ipc * neldo, 1), *), ainv(&
            &  ipc * nelup_mat, *), ainvup(ipc * nelup, *), ainvdo(max(ipc * neldo, 1), *), &
            &  ukwald, vj(dimvj), vjb(dimvj), vju(dimvju), vjub(dimvju), dist_kel(3), jastrow1&
            &, dd(dimdd), ddb(dimdd), &
            &  zeta(*), grad1(3), grad2, rion(3, *), iond(nion, *), dist(&
            &  nion, *), r(0:indt,nion), rmu(3, 0:indt,nion), ivic(3, &
            &  indtmax, *), vold, vpot, vpotreg, rc(3), &
            &  winvbar(ipc * ipf * nelorbh, *), detmat(ipc * ipf * nelorbh, *), detmatb(ipc * ipf * nelorbh, *), winvjbar(*), &
            &  jasmat(*), jasmatb(*), cnorm(*), prefactor(indt - istart + 1, *), &
            &  jasmat_c(*), jasmat_cb(*), muj_c(*), muj_cb(*), jasmatsz_c(*), jasmatsz_cb(*), &
            &  pseudolocal(*), rcutoff(*), parshell(3, *), wpseudo(*)&
            &, legendre(lmax - 1, *), versor(3, *), wintpseudo(*), vpseudolocal, costz(*), costz3(*), costz0, angle(18, *), &
            &  logpsi, eloc, psidetln, psidetlnt, jasmatsz(*), jasmatszb(*), winvjbarsz(*), &
            &  r0, iond_cart(3, nion, nion), cutreg, mu_c(*), mu_cb(*), detmat_c(*), detmat_cb(*)&
            &, vpseudolocalb, tabpipsav(nelup + neldo, indt + 4)
    REAL*8 :: tabpipb(nelup + neldo, indt + 4), tmub(nelup + neldo, indt) &
            &, psipb(*), winvb(ipc * nelorb, 0:0, nelup + neldo), winvjb(nelorbjmax, 0:0, &
            &  nelup + neldo), winvupb(ipc * nelup, indt + 4), winvdob(max(ipc * neldo, 1), indt + 4), &
            & ainvb(ipc * nelup_mat, nelup_mat), ukwaldb, dist_kelb(3), &
            &  grad1b(3), grad2b, rionb(3, nion), iond_cartb(3,nion, nion), &
            & distb(nion, nelup + neldo),rb(0:indt,nion),rmub(3,0:indt,nion),&
            & ivicb(3, indtmax, nelup + neldo), voldb, vpotb, rcb(3), winvbarb(ipc * ipf * nelorbh&
            &, nel_mat), winvjbarb(int(ipj * nelorbjh,8)*(nelup + neldo) + 1), &
            &   prefactorb(indt - istart + 1, nelup + neldo), &
            &  wpseudob(2 * lmax), legendreb(lmax - 1, nintpseudo), costz0b, logpsib(*), &
            &  elocb(*), psidetlntb(ipc), winvjbarszb(*), psisn, &
            &  r0b, ainvupb(ipc * nelup, nelorbh), ainvdob(max(ipc * neldo, 1), *),eagp_pfaffb(max(ipc*ndiff,1),max(ndiff,1))
    REAL*8 :: kel(3, nelup + neldo, 0:indt), kelind(3, nelup + neldo)
    REAL*8 :: kelb(3, nelup + neldo, 0:indt), kelindb(3, nelup + neldo)
    LOGICAL :: iessz, ieseloc, ieslog, iesiesd, yeszagp, yesdodet, yeszj, yesforce, notest, lrdmc_deru,donebig
    !************* PERIODIC WORLD ************************+
    REAL*8 :: lbox, rmucos(3, 0:indt,nion), rmusin(3, 0:indt,nion), &
            &  oldkappa, cellscaleb(3), s2rb(3, 3)
    REAL*8 :: lboxb, rmucosb(3, 0:indt,nion), rmusinb(3, 0:indt,nion)
    EXTERNAL IESDR2IESD
    INTEGER :: res
    ! compute everything by scratch.
    real*8 recipb(3, 3), metricb(3, 3), car2cryb(3, 3), omegab, cost, costb&
            &, matscra(3, 3), atb(3, 3), workscra(3), rc0b(3), rco0b(3)
    integer ipiv(3)
    real*8,  external:: cclock
    real*8 timep
    real*8 distsquare_node,weight_wagner
    real*8, external:: f_wagner
    real*8,dimension(:,:,:), allocatable:: winvb_big,winvjb_big
    !****************************************************
    !   vanishing all adjoint arrays and constants but elocb and logpsib
    !   It is assumed that all corresponding  vectors of the direct
    !   algorithm (without b) are initialized.

    nshelldoh = nshelldo
    nshellh = nshell
    nshelljh = nshellj

    if(lrdmc_der.and..not.lrdmc_nonodes) then
        lrdmc_deru = .true.
    else
        lrdmc_deru = .false.
    endif

    if(neldo.eq.0) then
        nelup1 = nelup
        zerop1 = 0
    else
        zerop1 = 1
        nelup1 = nelup + 1
    endif

    if(lrdmc_deru) then
        istartu = 1
    else
        istartu = istart
    endif

    nelcol = ipf * nelorbh + ndiff
    nelcol_c = nelorb_c + ndiff

    nelorbjh2o = (ipj * nelorbjh)*(ipj * nelorbjh)
    dimmuc = ipc * ipf * nelorbh * nelorb_c
    dimmujc = nelorbjh * nelorbj_c
    dimdetmat_c = ipc * nelorb_c * nelcol_c


    nel = nelup + neldo
    nelorbjc = nel * nelorbj_c
    nelorbjcp = nelorbjc + 1
    nelorbj_c2 = (ipj * nelorbj_c)*(ipj * nelorbj_c)

    if(ipj.eq.2) then
        nelused = nelup
    else
        nelused = nel
    endif
    nelorbju = ipj * nelorbjh

    recipb = 0.d0
    omegab = 0.d0
    metricb = 0.d0
    car2cryb = 0.d0
    dim_jasmat=1
    if(nelorbjh.gt.0) then
        if(iessz) winvjbarszb(1:nelorbjh * (nelup + neldo)) = 0.0_8
        if(yesfastj.eq.0) then
            if(iessz) jasmatszb(1:nelorbjh2o) = 0.0_8
            if(yes_sparse) then
            call dscalzero(nnozeroj,0.d0,jasmatb,1)
            dim_jasmat=nnozeroj
            else
            call dscalzero_(nelorbjh2o,0.d0,jasmatb,1)
            dim_jasmat=nelorbjh2o
            endif
        else
            call dscalzero_(dimmujc,0.d0,muj_cb,1)
            call dscalzero_(nelorbj_c2,0.d0,jasmat_cb,1)
            if(iessz) jasmatsz_cb(1:nelorbj_c2) = 0.d0
        endif
    endif
    if(yesfast.eq.0) then
!       detmatb(1:ipc * ipf * nelorbh, 1:nelcol) = 0.0_8
        call dscalzero_(ipc * ipf * nelorbh*nelcol,0.d0,detmatb,1)
    else
!       detmat_cb(1:dimdetmat_c) = 0.0_8
        call dscalzero_(dimdetmat_c,0.d0,detmat_cb,1)
!       mu_cb(1:dimmuc) = 0.0_8
        call dscalzero_(dimmuc,0.d0,mu_cb,1)
    endif
    if(npar_eagp.gt.0)  call dscalzero_(size(eagp_pfaffb),0.d0,eagp_pfaffb,1)

    cellscaleb = 0.d0
    s2rb = 0.d0
    winvupb = 0.0_8
    kelindb = 0.0_8
    ddb = 0.0_8
    vjb = 0.0_8
    vjub = 0.0_8
    rionb = 0.0_8
    iond_cartb = 0.0_8
    call dscalzero_(size(ainvb),0.d0,ainvb,1) 
    kelb = 0.0_8
    tmub = 0.0_8
    tabpipb = 0.0_8
    prefactorb = 0.0_8
    distb = 0.0_8
    call dscalzero_(size(winvbarb),0.d0,winvbarb,1)
    winvjbarb=0.d0
    ivicb = 0.0_8
    vpseudolocalb = 0.0_8
    call dscalzero_(size(winvb),0.d0,winvb,1)
    winvjb=0.d0
    vpotb = 0.0_8
    psidetlntb = 0.0_8
    call  dscalzero_(size(ainvupb),0.d0,ainvupb,1)
    winvdob = 0.0_8
    if(neldo.gt.0) then
    call dscalzero_(ipc * neldo*nelorbh,0.d0,ainvdob,1)
!       ainvdob(:, 1:nelorbh) = 0.0_8
    endif
    rb = 0.0_8
    rmub = 0.0_8
    rmucosb = 0.0_8
    rmusinb = 0.0_8

    !   Initialize not used
    psidetlnt = 0.d0
    vpseudolocal = 0.d0

    IF (iflag .NE. 0) return

    if(sum(abs(elocb(1:ipc))).ne.0.d0) then
        ieseloc = .true.
    else
        ieseloc = .false.
    endif

    if(sum(abs(logpsib(1:ipc))).ne.0.d0) then
        ieslog = .true.
    else
        ieslog = .false.
    endif

    nelorb5 = nelorb * (indt4 + 1)
    nelorbj5 = nelorbj * (indt4j + 1)
    nelorbup = nelorb * nelup
    nelorbdo = nelorb * neldo
    ip5 = 5

    nel = nelup + neldo
    !     independent input kelind rion
    kel(:, :, 0) = kelind(:, :)

    iesd = iesdr2iesd(iesdr)

    if(iesdr.eq.-7.or.iesd.lt.0.or.iesd.eq.2) then
        iesiesd = .true.
    else
        iesiesd = .false.
    endif

    if(iessz) then
        sizewsz = nelorbjh * nel
    else
        sizewsz = 1
    endif

    isdistp = nelorbjh * (indt + 5) + 27 * (indt + 1) * max(nshellj,nion)

    if(iessz) then
        ind1 = isdistp + 1
        ind2 = ind1 + 2 * nelorbjmax
        ind3 = ind2 + 2 * max(nel, indt + 5)
        ind4=ind3+(nel+nion)
        sizework1 = 2
    else
        ind1 = isdistp + 1
        ind2 = ind1 + ipj * nelorbjmax
        ind3 = ind2 + 2 * max(nel, indt + 5)
        ind4=ind3+(nel+nion)
        sizework1 = 1
    endif
!   write(6,*) ' HERE memory required = ',ind4+(indt+5)*nelorbjmax
    if(ieseloc.and.membigcpu) then
    donebig=.true.
    else
    donebig=.false.
    endif
    if(donebig) then
     if(yesforce.or.yeszagp) then
     allocate(winvb_big(ipc * nelorb, 0:indt+4, nel))
     winvb_big=0.d0
     endif
     if(nelorbjh.gt.0.and.(yesforce.or.yeszj)) then 
     allocate(winvjb_big(nelorbjmax, 0:indt+4,nel)) 
     winvjb_big=0.d0
     endif
    endif

    ! begin task # 11
    !     compute local energy given winvup winvdo tabpip
    !     output Local energy eloc

#ifdef _TIME
        timep=cclock()
#endif

    if(true_wagner.gt.0) then
         if(cutweight.gt.0.d0) then
          distsquare_node=0.d0
          if(true_wagner.eq.2) then
           do j=1,indt
            do i=1,ipc*nelup,ipc
    if(winvup(i,j).lt.0) distsquare_node=distsquare_node+winvup(i,j)*winvup(i,j) 
            enddo
           enddo
           do j=1,indt
            do i=1,ipc*neldo,ipc
    if(winvdo(i,j).lt.0) distsquare_node=distsquare_node+winvdo(i,j)*winvup(i,j)
            enddo
           enddo
           if(distsquare_node.gt.0.d0) then
           distsquare_node=1.d0/distsquare_node/(cutweight*cutweight)
           weight_wagner=f_wagner(distsquare_node)
           else
           weight_wagner=1.d0
           endif
          else
           do i=1,ipc*nelup
           distsquare_node=distsquare_node+sum(winvup(i,indt+1:indt+3)*winvup(i,indt+1:indt+3))
           enddo
           do i=1,ipc*neldo
           distsquare_node=distsquare_node+sum(winvdo(i,indt+1:indt+3)*winvdo(i,indt+1:indt+3))
           enddo
           distsquare_node=1.d0/distsquare_node/(cutweight*cutweight)
           weight_wagner=f_wagner(distsquare_node)
          endif 
         else
         weight_wagner=1.d0
         endif
         if(ieseloc) then
         elocb(1:ipc)=elocb(1:ipc)*weight_wagner
         else
         logpsib(1:ipc)=logpsib(1:ipc)*weight_wagner
         endif
    endif

    if(ieseloc) then
        CALL TASK11_B(winvup, winvupb, winvdo, winvdob, tabpip, tabpipb, &
                &            tmu, tmub, vpot, vpotb, eloc, elocb)
#ifdef _TIME
        timingsb(11)=timingsb(11)+cclock()-timep
        timep=cclock()
#endif
        if(yesdodet) CALL TASK10_B(ainv, ainvb, winvbar, winvbarb, kel, kelb, rion, rionb, ainvup&
                &, ainvupb, ainvdo, ainvdob, winvup, winvupb, winvdo, winvdob, cellscaleb, s2rb, psip, psipb)
#ifdef _TIME
        timingsb(10)=timingsb(10)+cclock()-timep
        timep=cclock()
#endif
    endif

    CALL TASK9_B(kel, kelb, rion, rionb, winvj, winvjb, winvjbar, &
            &           winvjbarb, winvjbarsz, winvjbarszb, ivic, &
            &      ivicb, tabpip, tabpipb, vj, vjb, vju, vjub, psidetlnt, psidetlntb, logpsi, logpsib&
            &, psip(ind1), psipb(ind1), psip(ind4), psipb(ind4), psip, psipb, psip(ind2), psipb(ind2)&
  &, cellscaleb, s2rb, metricb, car2cryb,ipsip,psip(ind3),psipb(ind3))

#ifdef _OFFLOAD
!$omp target update to (winvjb,winvjbarb)
#endif
#ifdef _TIME
        timingsb(9)=timingsb(9)+cclock()-timep
        timep=cclock()
#endif

    if(yesdodet) CALL TASK8_B(winv, winvb, winvbar, winvbarb, psidetlnt, psidetlntb, &
            &           ainv, ainvb)


#ifdef _TIME
        timingsb(8)=timingsb(8)+cclock()-timep
        timep=cclock()
#endif

    if(ieseloc.and.yesforce) then
        CALL TASK7_B(kelind, kelindb, rion, rionb, vpseudolocal, vpseudolocalb&
                &, vpot, vpotb, cellscaleb, recipb, omegab)

#ifdef _TIME
        timingsb(7)=timingsb(7)+cclock()-timep
        timep=cclock()
#endif
      CALL TASK6_B(kelind, kelindb, rion, rionb, iond_cart, iond_cartb, vpot, &
                & vpotb, cellscaleb, s2rb)
#ifdef _TIME
        timingsb(6)=timingsb(6)+cclock()-timep
        timep=cclock()
#endif
    endif

    CALL TASK5_B(winv, winvb, winvj, winvjb, jasmat, jasmatb, jasmatsz, jasmatszb &
            &, muj_c, muj_cb, jasmat_c, jasmat_cb, jasmatsz_c, jasmatsz_cb &
            &, detmat, detmatb, mu_c, mu_cb, detmat_c, detmat_cb, winvbar, winvbarb, winvjbar&
            &, winvjbarb, winvjbarsz, winvjbarszb)
#ifdef _TIME
        timingsb(5)=timingsb(5)+cclock()-timep
        timep=cclock()
#endif


    if(yeszj.or.yeszagp.or.yesforce) then
#ifdef  _OFFLOAD
!$omp target update from (winvb,winvjb)
#endif
        CALL TASK4_B(kel, kelb, rion, rionb, dd, ddb, vju, vjub, winv, winvb, winvj&
                &, winvjb, cellscaleb, s2rb)
#ifdef _TIME
        timingsb(4)=timingsb(4)+cclock()-timep
        timep=cclock()
#endif

    endif

    if(yesforce) then

        if(ieseloc) then
            CALL TASK3_B(rion, rionb, iond_cart, iond_cartb, cellscaleb, s2rb)
#ifdef _TIME
        timingsb(3)=timingsb(3)+cclock()-timep
        timep=cclock()
#endif

            CALL TASK2_B(kelind, kelindb, rion, rionb, dist, distb, kel, kelb, &
                    & vpseudolocal, vpseudolocalb, prefactor, prefactorb, &
                    & ivic, ivicb, tmu, tmub, cellscaleb, s2rb, car2cryb, metricb)
#ifdef _TIME
        timingsb(2)=timingsb(2)+cclock()-timep
        timep=cclock()
#endif

            CALL TASK1_B(kelind, kelindb, rion, rionb, dist, distb, cellscaleb, s2rb)
#ifdef _TIME
        timingsb(1)=timingsb(1)+cclock()-timep
        timep=cclock()
#endif
        endif

        kelindb(:, :) = kelindb(:, :) + kelb(:, :, 0)
        kelb(:, :, 0) = 0.0_8


    endif

    if(iespbc) then
        !   reverse of given s2r compute omega the volume  and  recip
        !   omega=det(s2r)
        !   cost=TWO_PI/omega
        !   recip(1,:)=cross_product(s2r(:,2), s2r(:,3))*cost
        !   recip(2,:)=cross_product(s2r(:,3), s2r(:,1))*cost
        !   recip(3,:)=cross_product(s2r(:,1), s2r(:,2))*cost
        cost = TWO_PI / omega
        workscra(:) = recipb(1, :)
        s2rb(:, 2) = s2rb(:, 2) - cross_product(workscra, s2r(1, 3)) * cost
        s2rb(:, 3) = s2rb(:, 3) - cross_product(s2r(1, 2), workscra) * cost

        workscra(:) = recipb(2, :)
        s2rb(:, 1) = s2rb(:, 1) - cross_product(s2r(1, 3), workscra) * cost
        s2rb(:, 3) = s2rb(:, 3) - cross_product(workscra, s2r(1, 1)) * cost

        workscra(:) = recipb(3, :)
        s2rb(:, 1) = s2rb(:, 1) - cross_product(workscra, s2r(1, 2)) * cost
        s2rb(:, 2) = s2rb(:, 2) - cross_product(s2r(1, 1), workscra) * cost

        costb = sum(recipb(:, :) * recip(:, :)) / cost

        recipb = 0.d0
        matscra = transpose(s2r)
        call dgetrf(3, 3, matscra, 3, ipiv, info)
        call dgetri(3, matscra, 3, ipiv, workscra, 3, info)
        !   s2rb=s2rb-cost*costb*matscra
        omegab = omegab - costb * cost / omega
        !   compute omega=det(s2r)
        s2rb = s2rb + omegab * omega * matscra
        omegab = 0.d0
        !   reverse of given s2r compute metric
        !
        ! Reverse of  Given at  compute car2cry=at^-1
        matscra = matmul(transpose(car2cry), car2cryb)
        atb = -matmul(matscra, transpose(car2cry))

        ! Reverse of  Given at compute the metric
        !   metric=transpose(at) at
        matscra = metricb + transpose(metricb)
        atb = atb + matmul(at, matscra)

        !   Given  s2r and cellscale compute at
        !   at=s2r(:,k)/cellscale(k)
        do k = 1, 3
            s2rb(:, k) = s2rb(:, k) + atb(:, k) / cellscale(k)
            cellscaleb(k) = cellscaleb(k) - sum(atb(:, k) * s2r(:, k)) / (cellscale(k)*cellscale(k))
        enddo
        ! reverse of cellscale=sqrt(sum(s2r(:,1)**2)) Important for pseudo and twobody
        do k = 1, 3
            s2rb(:, k) = s2rb(:, k) + cellscaleb(k) / cellscale(k) * s2r(:, k)
        enddo
    endif
    !  At the end symmetrize AGP if requested.
    if(ipf.eq.2) then
        if(yesfast.eq.0) then
            call  symmetrizepfaff(ipc, ndim_detmat, detmatb)
        else
            call  symmetrizepfaff(ipc, ndim_detmat, detmat_cb)
        endif
        if(npar_eagp.gt.0) then
            call symmetrizepfaff(ipc, ndiff, eagp_pfaffb)
        endif
    endif
    if(notest) then
        if(symmagp.and.(ipc.eq.1.or.(ipc.eq.2.and..not.yes_correct))) then
            !    In the complex case with yes_correct=.true. we cannot symmetrize
            if(yesfast.eq.0) then
                call symmetrize(ipc, ipf, yes_hermite, nelorbh, nelorb_at, detmatb)
            else
                call symmetrize(ipc, ipf, yes_hermite, nelorb_c / ipf, nelorb_at, detmat_cb)
            endif
        endif
        if(nelorbj.gt.0) then
            if(yesfastj.eq.0) then
            if(.not.yes_sparse) call symmetrize(1, 1, .false., ipj * nelorbjh, ipj * nelorbjh, jasmatb)
                if(iessz) call symmetrize_(1, 1, .false., nelorbjh, nelorbjh, jasmatszb)
            else
                call symmetrize(1, 1, .false., ipj * nelorbj_c, ipj * nelorbj_c, jasmat_cb)
                if(iessz) call symmetrize_(1, 1, .false., nelorbj_c, nelorbj_c, jasmatsz_cb)
            endif
        endif
    endif
    ! derivative in the direction of the principal axes
    if(iespbc) then
        do k = 1, 3
            cellscaleb(k) = sum(at(:, k) * s2rb(:, k))  ! for compatibility with the dynamic
        enddo
    endif

     if(allocated(winvb_big))  deallocate(winvb_big)
     if(allocated(winvjb_big)) deallocate(winvjb_big) 


    return

CONTAINS
    !  Differentiation of task9 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: vju cnorm ivic r
    !                rmusin rmucos rmu zeta lbox winvjbarsz work1 work2
    !                work3 winvj rion psidetlnt kel tmu tabpip prefactor
    !                winvjbar
    !   of linear combination of output variables: cnorm r rmusin rmucos
    !                rmu zeta logpsi work1 work2 work3 rion kel tmu
    !                tabpip
    SUBROUTINE TASK9_B(kel, kelb, rion, rionb, winvj, winvjb, winvjbar, &
            &    winvjbarb, winvjbarsz, winvjbarszb, ivic, ivicb, &
            &   tabpip, tabpipb, vj, vjb, vju, vjub, psidetlnt, psidetlntb, logpsi, logpsib, work1, &
            &    work1b, work2, work2b, work3, work3b, vecu, vecub, cellscaleb, s2rb, metricb, car2cryb,ispin_n,vold_n,voldb_n)
        IMPLICIT NONE
        !      input kel rion winvj,winvjbar,winvjbarsz (if spin Jastrow on)
        !      prefactor
        !      output tabpip(nel,indt+4),logpsi
        !      logpsi is the logarithm |psi| without the Determinantal part
        !      all the rest is just used to evaluate tabpip
        REAL*8, INTENT(IN) :: kel(3, nel), rion(3, nion), winvj(&
                &    nelorbjmax, 0:indt4j, nel), winvjbar(*), winvjbarsz(sizewsz), &
                &     psidetlnt
        REAL*8 :: kelb(3, nel), rionb(3, nion), winvjb(nelorbjmax, 0&
                &:0, nel), winvjbarb(int(ipj * nelorbjh,8)*nel+1), winvjbarszb(sizewsz), &
                &    psidetlntb(*)
        REAL*8 :: tabpip(nel, indt + 4), logpsi
        REAL*8 :: tabpipb(nel, indt + 4), logpsib(*)
        REAL*8 :: work1(ipj * nelorbjmax, sizework1), work2(nelorbjmax, 0:indt + 4)
        REAL*8 :: work1b(ipj * nelorbjmax, sizework1), work2b(nelorbjmax, 0:indt + 4)
        REAL*8 :: JASTROW_EI, JASTROW_EE, work3(isdistp)
        REAL*8 :: work3b(isdistp), rco(3), rcob(3), jastrownb, r0o, r0ob
        REAL*8 :: ivicb(3, indtmax, nelup + neldo), ivic(3, indtmax, nelup + neldo)
        REAL*8 :: rc0(3), rc0o(3), rc1(3), rco0(3), cellscaleb(3)&
                &, s2rb(3, 3), metricb(3, 3), car2cryb(3, 3), rc_before(3), rco_before(3), rc0_before(3)&
                &, rco0_before(3),rc(3),rcb(3)
        real*8 :: vj(*), vjb(niesd), vju(*), vjub(*), vecu(max(nel, indt + 5), 2), vecub(max(nel, indt + 5), 2)
        INTEGER :: indtaj, indtmp,  nelused
        integer*8 ji, jf,ii,maxii,indj
        REAL*8 :: tempb0(3)
        INTRINSIC SUM
        REAL*8 :: tempb, costz0t, costz0e, costz0b, w0, wj, costexp, ddot2, ddotj, ddot2b, ddotjb, w0b, wjb&
                &, ddotb
        real*8 vold_n(nel+nion),voldb_n(nel+nion)
        integer ispin_n(nel)
        voldb_n=0.d0

        tabpipsav = tabpip

        psidetlntb(1:ipc) = logpsib(1:ipc) + psidetlntb(1:ipc)

        nelused = nelup + mod(ipj, 2) * neldo

        if(nelorbjh.gt.0) then

            !      recompute work1

            do k=1,nelorbju
            work1(k, 1) = winvjbar(k)
            enddo
!$omp parallel do default(shared) private(k,j)
           do k=1,nelorbju
            do j = 2, nel
            work1(k, 1) = work1(k, 1) + winvjbar((j - 1) * nelorbju + k)
            enddo
           enddo
            if(iessz) then
                work1(:, 2) = winvjbarsz(1:nelorbjh)
                do j = 2, nelup
                    work1(:, 2) = work1(:, 2) + winvjbarsz((j - 1) * nelorbjh + 1:j * nelorbjh)
                enddo
                do j = nelup + 1, nel
                    work1(:, 2) = work1(:, 2) - winvjbarsz((j - 1) * nelorbjh + 1:j * nelorbjh)
                enddo
            endif

            work1b = 0.d0
            work2b = 0.d0
            work3b = 0.d0
            vecub = 0.d0

            if(ieslog) then
                !   Calculation wavefunction
                if(iessz) then
                    do j = nelup + 1, nel
                        vecub(j, 1) = -0.5d0 * logpsib(1)
                        vecub(j, 2) = -0.5d0 * logpsib(1)
                    enddo
                    !         do j=nelup+1,nel
                    !         logpsi(1)=logpsi(1)-0.5d0*(vecu(j,1)+vecu(j,2))
                    !         enddo
                    do j = 1, nelup
                        vecub(j, 1) = 0.5d0 * logpsib(1)
                        vecub(j, 2) = -0.5d0 * logpsib(1)
                    enddo
                    !          do j=1,nelup
                    !          logpsi(1)=logpsi(1)+0.5d0*(vecu(j,1)-vecu(j,2))
                    !          enddo
                    do j = 1, nel
                        indj = int(j - 1,8) * nelorbjh + 1
                        call ddot_b(nelorbjh, winvj(1, 0, j), winvjb(1, 0, j), winvjbarsz(indj), winvjbarszb(indj), vecub(j, 2))
                        !      winvjb(:,0,j)=winvjb(:,0,j)+vecub(j,2)*winvjbarsz(ji:jf)
                        !      winvjbarszb(ji:jf)=winvjbarszb(ji:jf)+vecub(j,2)*winvj(:,0,j)
                        !      vecub(j,2)=0.d0
                    enddo
                    !      do j=1,nel
                    !      vecu(j,2)=sum(winvj(:,0,j)*winvjbarsz((j-1)*nelorbjh+1:j*nelorbjh))
                    !      enddo
                    call DGEMV_B('T', nelorbjh, nel, 1.d0, winvj, nelorbj5, winvjb, nelorbjh, work1(1, 2), 1&
                            &, work1b(1, 2), 1, 0.d0, vecub, 1)
                    !    call dgemv('T',nelorbjh,nel,1.d0,winvj,nelorbj5,work1(1,2),1,0.d0,vecu,1)
                endif ! iessz

                do j = 1, nel
                    vecub(j, 1) = 0.5d0 * logpsib(1)
                    vecub(j, 2) = -0.5d0 * logpsib(1)
                enddo
                !      do j=1,nel
                !      logpsi(1)=logpsi(1)+0.5d0*(vecu(j,1)-vecu(j,2))
                !      enddo

                do j = 1, nel
                    if (ipj==2) then
                        if (j<=nelup) then
                            indj = int(j - 1,8) * int(nelorbjh * ipj,8) + 1
                            !      jf=j*nelorbjh
                            call ddot_b(nelorbjh, winvj(1, 0, j), winvjb(1, 0, j), winvjbar(indj), winvjbarb(indj), vecub(j, 2))
                        else
                            indj = (j - 1) * nelorbjh * ipj + nelorbjh + 1
                            call ddot_b(nelorbjh, winvj(1, 0, j), winvjb(1, 0, j), winvjbar(indj), winvjbarb(indj), vecub(j, 2))
                        endif
                    else
                        indj = int(j - 1,8) * nelorbjh + 1
                        call ddot_b(nelorbjh, winvj(1, 0, j), winvjb(1, 0, j), winvjbar(indj), winvjbarb(indj), vecub(j, 2))
                    endif
                    !      winvjb(:,0,j)=winvjb(:,0,j)+vecub(j,2)*winvjbar(ji:jf)
                    !      winvjbarb(ji:jf)=winvjbarb(ji:jf)+vecub(j,2)*winvj(:,0,j)
                    !      vecub(j,2)=0.d0
                enddo
                !       do j=1,nel
                !       vecu(j,2)=sum(winvj(:,0,j)*winvjbar((j-1)*nelorbjh+1:j*nelorbjh))
                !       enddo

                call DGEMV_B('T', nelorbjh, nelused, 1.d0, winvj, nelorbj5, winvjb, nelorbjh, work1, 1&
                        &, work1b, 1, 0.d0, vecub, 1)
                if (ipj==2) then
                    call DGEMV_B('T', nelorbjh, neldo, 1.d0, winvj(1, 0, nelup1), nelorbj5&
                            &, winvjb(1, 0, nelup1), nelorbjh, work1(1 + nelorbjh, 1), 1&
                            &, work1b(1 + nelorbjh, 1), 1, 0.d0, vecub(nelup1, 1), 1)
                endif

                !       call dgemv('T',nelorbjh,nel,1.d0,winvj,nelorbj5,work1,1,0.d0,vecu,1)
            endif ! endif ieslog

            if(ieseloc) then
                do j = 1, nel
                    indtaj = indtm(j) + 5
                    indj = int(j - 1,8) * nelorbju + 1
                    indtmp = indtm(j) + 1
                    !       recomputing work2
                    if(indt4j.eq.0) then
                        call upnewwf(indt, 0, indtm(j), 0, nshelljh, ioptorbj, ioccj, kel(1, j)  &
                                &, nel, r, rmu, vju, zeta, rion, work3, work2, nelorbjh, nion, kionj     &
                                &, iflagnorm, cnorm(nshell + 1), LBox, rmucos, rmusin, 1d-9&
                                &, indparj_tab, indorbj_tab, indshellj_tab, .true.)
                        !   Put consecutive information
                        do k = 1, 4
                            work2(:, indtm(j) + k) = work2(:, indt + k)
                        enddo
                    else
                        !   Put consecutive information
                        work2(:, 0:indtm(j)) = winvj(:, 0:indtm(j), j)
                        do k = 1, 4
                            work2(:, indtm(j) + k) = winvj(:, indt + k, j)
                        enddo
                    endif

                    if(iessz) then
                        !       Recomputing vecu
                        call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, winvjbarsz(indj), 1, 0.d0, vecu, 1)
                        call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work1(1, 2), 1, 0.d0, vecu(1, 2), 1)
                        if(j.le.nelup) then
                            do k = 1, 4
                                vecub(k + indtmp, 2) = tabpipb(j, k + indt)
                                vecub(k + indtmp, 1) = -tabpipb(j, k + indt)
                            enddo
                            !         do k=1,4
                            !         tabpip(j,k+indt)=tabpip(j,k+indt)+vecu(k+indtmp,2)-vecu(k+indtmp,1)
                            !         enddo

                            do k = 1, indtm(j)
                                if(tabpip(j, k).ne.0.d0) then
                                    vecub(k + 1, 2) = tabpipb(j, k) * tabpip(j, k)
                                    costexp = exp(vecu(k + 1, 2) - vecu(1, 2) - vecu(k + 1, 1) + vecu(1, 1))
                                    !          reverse back tabpip  to have the same input of the direct algorithm
                                    tabpip(j, k) = tabpip(j, k) / costexp
                                    tabpipb(j, k) = tabpipb(j, k) * costexp
                                    vecub(1, 2) = vecub(1, 2) - vecub(k + 1, 2)
                                    vecub(k + 1, 1) = -vecub(k + 1, 2)
                                    vecub(1, 1) = vecub(1, 1) + vecub(k + 1, 2)
                                endif
                            enddo
                            !         do k=1,indtm(j)
                            !          if(tabpip(j,k).ne.0.d0) then
                            !       tabpip(j,k)=tabpip(j,k)*exp(vecu(k+1,2)-vecu(1,2)-vecu(k+1,1)+vecu(1,1))
                            !          endif
                            !         enddo

                        else

                            do k = 1, 4
                                vecub(k + indtmp, 2) = -tabpipb(j, k + indt)
                                vecub(k + indtmp, 1) = -tabpipb(j, k + indt)
                            enddo
                            !         do k=1,4
                            !         tabpip(j,k+indt)=tabpip(j,k+indt)-vecu(k+indtmp,2)-vecu(k+indtmp,1)
                            !         enddo

                            do k = 1, indtm(j)
                                !          recomputing wj
                                if(tabpip(j, k).ne.0.d0) then
                                    costexp = exp(-vecu(k + 1, 2) + vecu(1, 2) - vecu(k + 1, 1) + vecu(1, 1))
                                    vecub(k + 1, 2) = -tabpipb(j, k) * tabpip(j, k)
                                    vecub(k + 1, 1) = vecub(k + 1, 2)
                                    vecub(1, 2) = vecub(1, 2) - vecub(k + 1, 2)
                                    vecub(1, 1) = vecub(1, 1) - vecub(k + 1, 2)
                                    !          reverse back tabpip  to have the same input of the direct algorithm
                                    tabpip(j, k) = tabpip(j, k) / costexp
                                    tabpipb(j, k) = tabpipb(j, k) * costexp
                                endif
                            enddo
                            !         do k=1,indtm(j)
                            !          if(tabpip(j,k).ne.0.d0) then
                            !       tabpip(j,k)=tabpip(j,k)*exp(-vecu(k+1,2)+vecu(1,2)-vecu(k+1,1)+vecu(1,1))
                            !          endif
                            !         enddo
                        endif
                        call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, work1(1, 2), 1&
                                &, work1b(1, 2), 1, 0.d0, vecub(1, 2), 1)
                        call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, winvjbarsz(indj), 1&
                                &, winvjbarszb(indj), 1, 0.d0, vecub, 1)
                        !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,winvjbarsz(indj),1,0.d0,vecu,1)
                        !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,work1(1,2),1,0.d0,vecu(1,2),1)

                    endif ! endif iessz

                    !     Recomputing vecu
                    !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,winvjbar(indj),1,0.d0,vecu,1)
                    !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,work1,1,0.d0,vecu(1,2),1)
                    if (ipj==2) then
                        if (j<=nelup) then
                            call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, winvjbar(indj), 1, 0.d0, vecu, 1)
                            call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work1, 1, 0.d0, vecu(1, 2), 1)
                        else
                            call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, winvjbar(indj + nelorbjh), 1, 0.d0, vecu, 1)
                            call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work1(1 + nelorbjh, 1), 1, 0.d0, vecu(1, 2), 1)
                        endif
                    else
                        call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, winvjbar(indj), 1, 0.d0, vecu, 1)
                        call dgemv('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work1, 1, 0.d0, vecu(1, 2), 1)
                    endif

                    do k = 1, 4
                        vecub(k + indtmp, 1) = -tabpipb(j, k + indt)
                        vecub(k + indtmp, 2) = tabpipb(j, k + indt)
                    enddo
                    !          do k=1,4
                    !          tabpip(j,k+indt)=tabpip(j,k+indt)+vecu(k+indtmp,2)-vecu(k+indtmp,1)
                    !          enddo
                    do k = 1, indtm(j)
                        if(tabpip(j, k).ne.0.d0) then
                            costexp = exp(vecu(k + 1, 2) - vecu(1, 2) - vecu(k + 1, 1) + vecu(1, 1))
                            vecub(k + 1, 2) = tabpipb(j, k) * tabpip(j, k)
                            !           restoring tabpip original input of the direct
                            tabpip(j, k) = tabpip(j, k) / costexp
                            tabpipb(j, k) = tabpipb(j, k) * costexp
                            vecub(1, 2) = vecub(1, 2) - vecub(k + 1, 2)
                            vecub(k + 1, 1) = -vecub(k + 1, 2)
                            vecub(1, 1) = vecub(1, 1) + vecub(k + 1, 2)
                        endif
                    enddo
                    !          do k=1,indtm(j)
                    !           if(tabpip(j,k).ne.0.d0) then
                    !           tabpip(j,k)=tabpip(j,k)*exp(vecu(k+1,2)-vecu(1,2)-vecu(k+1,1)+vecu(1,1))
                    !           endif
                    !          enddo

                    if (ipj==2) then
                        if (j<=nelup) then
                            call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, work1, 1&
                                    &, work1b, 1, 0.d0, vecub(1, 2), 1)
                            call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, winvjbar(indj), 1&
                                    &, winvjbarb(indj), 1, 0.d0, vecub, 1)
                        else
                            call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, work1(1 + nelorbjh, 1), 1&
                                    &, work1b(1 + nelorbjh, 1), 1, 0.d0, vecub(1, 2), 1)
                            call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, winvjbar(indj + nelorbjh), 1&
                                    &, winvjbarb(indj + nelorbjh), 1, 0.d0, vecub, 1)
                        endif
                    else
                        call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, work1, 1&
                                &, work1b, 1, 0.d0, vecub(1, 2), 1)
                        call DGEMV_B('T', nelorbjh, indtaj, 1.d0, work2, nelorbjh, work2b, nelorbjh, winvjbar(indj), 1&
                                &, winvjbarb(indj), 1, 0.d0, vecub, 1)
                    endif
                    !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,winvjbar(indj),1,0.d0,vecu,1)
                    !      call dgemv('T',nelorbjh,indtaj,1.d0,work2,nelorbjh,work1,1,0.d0,vecu(1,2),1)



                    !          Put the information consecutive
                    do k = 4, 1, -1
                        work2b(:, indt + k) = work2b(:, indtm(j) + k)
                    enddo
                    if(indt.gt.indtm(j)) work2b(:, indtm(j) + 1:indt) = 0.d0
                    if(yeszj.or.yesforce) then
                        if(.not.donebig) then
                        call UPNEWWF_B(indt, 0, indtm(j), 0, nshelljh, ioptorbj, ioccj, kel(1, j), kelb(1, j)&
                                &, nel, r, rb, rmu, rmub, vju, vjub, zeta, rion, rionb, work3, work3b, work2&
                                &, work2b, nelorbjh, nion, kionj, iflagnorm, cnorm(nshell + 1), LBox&
                                &, rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb&
                                &, indparj_tab, indorbj_tab, indshellj_tab, adrj_nion, indj_nion)
                        else
                        winvjb_big(:,0:indtm(j),j)=winvjb_big(:,0:indtm(j),j)+work2b(:,0:indtm(j))
                        work2b(:,0:indtm(j))=0.d0
                        winvjb_big(:,indt+1:indt+4,j)=winvjb_big(:,indt+1:indt+4,j)+work2b(:,indt+1:indt+4)
                        work2b(:,indt+1:indt+4)=0.d0
                        endif
                    endif
                enddo ! end do j
            endif ! endif ieseloc

            do j = 1, nel
                ji = int(j - 1,8) * nelorbju + 1
                jf = int(j,8) * nelorbju
                winvjbarb(ji:jf) = winvjbarb(ji:jf) + work1b(1:nelorbju, 1)
            enddo

            work1b(:, 1) = 0.d0
            if(iessz) then
                do j = 1, nelup
                    ji = (j - 1) * nelorbjh + 1
                    jf = j * nelorbjh
                    winvjbarszb(ji:jf) = winvjbarszb(ji:jf) + work1b(:, 2)
                enddo
                do j = nelup + 1, nel
                    ji = (j - 1) * nelorbjh + 1
                    jf = j * nelorbjh
                    winvjbarszb(ji:jf) = winvjbarszb(ji:jf) - work1b(:, 2)
                enddo
                work1b(:, 2) = 0.d0
            endif
        endif ! endif nelorbj>0





        !        Reverse of 2-body
        if(ieslog) then
            call  up2bodypsi_b(nel, nelup, logpsi, logpsib, kel, kelb, vj, vjb, iesdr&
                    &, rion, rionb, nion, costz, costz3, LBox, niesd, cellscaleb, metricb, car2cryb)
        endif


        !        first two body part reverse

        if((ncore.gt.0.or.lrdmc_deru).and.ieseloc) then
            ! only if you are not doing VMC or SR or you have a non local potential
            do j = 1, nel
                do i = 1, indtm(j)
                    tabpip(j, i) = 1.d0
                enddo
                do i = indtm(j) + 1, indt
                    tabpip(j, i) = 0.d0
                enddo
            enddo


            if(niesd.ne.0) then

                !do for the first particle
!$omp parallel do default(shared) private(j1,i,costz0e,costz0,j2,ispin_n,vold_n,rc&
!$omp ,rco,kk,r0,r0o,rc0,rc0o,rc1,costz0t,costz0b,rco0,jastrownb&
!$omp ,r0b,r0ob,rcb,rcob,rc_before,rco_before,rc0_before,rco0_before&
!$omp ,rc0b,rco0b,voldb_n) reduction(+:kelb,rionb,cellscaleb,metricb,car2cryb,vjb) 
                !#endif
                do j1 = 1, nel
                voldb_n=0.d0
                       do j2=1,nel
                                if(iesiesd) then
                                    if((j1.le.nelup.and.j2.le.nelup).or.(j1.gt.nelup.and.j2.gt.nelup)) then
                                        ! parallel spins
                                        ispin_n(j2) = 1
                                    else
                                        ispin_n(j2) = -1
                                    endif
                                else
                                    ispin_n(j2) = -1
                                endif

                                if(j2.ne.j1) then
                                    rco(:) = kel(:, j1) - kel(:, j2)

                                    !************* PERIODIC WORLD *********************
                                    if(LBox.gt.0.d0) then
!                                       call CartesianToCrystal(rco, 1)
  rco(:)=car2cry(:,1)*rco(1)+car2cry(:,2)*rco(2)+car2cry(:,3)*rco(3)
                                        do kk = 1, 3
                                            rco(kk) = map(rco(kk), cellscale(kk))
                                            !       rco(1:3)=cellpi(:)*dsin(rco(:)/cellpi(:))
                                        enddo
                                    endif
                                    !************* PERIODIC WORLD *********************

                          vold_n(j2) = jastrow_ee(rco, vj, iesd, ispin_n(j2))
                                endif
                    enddo

                    if(n_body_on.ne.0) then

                     do j2=1,nion

                                if(LBox.gt.0.d0) then
                                    rc0o(:) = kel(:, j1) - rion(:, j2)
!                                   call CartesianToCrystal(rc0o, 1)
  rc0o(:)=car2cry(:,1)*rc0o(1)+car2cry(:,2)*rc0o(2)+car2cry(:,3)*rc0o(3)
                                    do kk = 1, 3
                                        rco(kk) = map(rc0o(kk), cellscale(kk))
                                    enddo
                                    r0o = norm_metric(rco, metric)
                                else
                                    rco(:) = costz(j2) * (kel(:, j1) - rion(:, j2))
                                    r0o = dsqrt(sum(rco(:)*rco(:)))
                                endif

             vold_n(j2+nel) = jastrow_ei(r0o, vj(pointvj(1, j2)), pointvj(2, j2))


                     enddo

                    endif

                    !do for the nearest neighbours
                    do i = istartu, indtm(j1)

                        if(n_body_on.ne.0) then
                            !       el-el jastrow 2 body

                            costz0e = 0.d0
                            !do for the second particle
                            do j2 = 1, nel
                                if(j2.ne.j1) then

                                    rc(:) = kel(:, j1) + ivic(:, i, j1) - kel(:, j2)

                                    !************* PERIODIC WORLD *********************
                                    if(LBox.gt.0.d0) then
!                                       call CartesianToCrystal(rc, 1)
     rc(:)=car2cry(:,1)*rc(1)+car2cry(:,2)*rc(2)+car2cry(:,3)*rc(3)

                                        do kk = 1, 3
                                            !        rc(kk)=cellpi(kk)*dsin(rc(kk)/cellpi(kk))
                                            rc(kk) = map(rc(kk), cellscale(kk))
                                        enddo
                                    endif
                                    !************* PERIODIC WORLD *********************

          costz0e = costz0e + jastrow_ee(rc, vj, iesd, ispin_n(j2)) - vold_n(j2)
                                endif
                            enddo

                            !       do not change tabpip for the next update
                            !       tabpip(j1,i)=tabpip(j1,i)*dexp(costz0)

                            costz0 = 0.d0

                            do j2 = 1, nion !do for the second particle
                                if(LBox.gt.0.d0) then
                                    rc1(:) = kel(:, j1) + ivic(:, i, j1) - rion(:, j2)
!                                   call CartesianToCrystal(rc1, 1)
  rc1(:)=car2cry(:,1)*rc1(1)+car2cry(:,2)*rc1(2)+car2cry(:,3)*rc1(3)

                                    do kk = 1, 3
                                        rc(kk) = costz(j2) * map(rc1(kk), cellscale(kk))
                                    enddo
                                    r0 = norm_metric(rc, metric)
                                else
                                    rc(:) = costz(j2) * (kel(:, j1) + ivic(:, i, j1) - rion(:, j2))
                                    r0 = dsqrt(sum(rc(:)*rc(:)))
                                endif
                                costz0 = costz0 - costz3(j2) * (jastrow_ei(r0, vj(pointvj(1, j2)), pointvj(2, j2)) - vold_n(j2+nel))

                            enddo ! j2


                            !       do not update tabpip
                            !       tabpip(j1,i)=tabpip(j1,i)*dexp(costz0)
                            costz0t = dexp(costz0 + costz0e)  ! in this step tabpip contained the el-el contr.

                            costz0b = tabpipb(j1, i) * costz0t
                            tabpipb(j1, i) = tabpipb(j1, i) * dexp(costz0)

                            do j2 = 1, nion !do for the second particle

                                if(LBox.gt.0.d0) then
                                    rc0(:) = kel(:, j1) + ivic(:, i, j1) - rion(:, j2)
                                    rc0_before(:) = rc0(:)
!                                   call CartesianToCrystal(rc0, 1)
     rc0(:)=car2cry(:,1)*rc0(1)+car2cry(:,2)*rc0(2)+car2cry(:,3)*rc0(3)
                                    do kk = 1, 3
                                        rc(kk) = costz(j2) * map(rc0(kk), cellscale(kk))
                                    enddo
!                                    rco0(:) = kel(:, j1) - rion(:, j2)
!                                    rco0_before(:) = rco0(:)
!                                   call CartesianToCrystal(rco0, 1)
!  rco0(:)=car2cry(:,1)*rco0(1)+car2cry(:,2)*rco0(2)+car2cry(:,3)*rco0(3)
!                                    do kk = 1, 3
!                                        rco(kk) = costz(j2) * map(rco0(kk), cellscale(kk))
!                                    enddo
                                else
                                    rc(:) = costz(j2) * (kel(:, j1) + ivic(:, i, j1) - rion(:, j2))
!                                    rco(:) = costz(j2) * (kel(:, j1) - rion(:, j2))
                                endif



                                !       reverse of
                                !       tabpip(j1,i)=tabpip(j1,i)*dexp(costz0)
                                !       costz0b=tabpipb(j1,i)*tabpip(j1,i)*dexp(costz0)
                                !       reverse of
                                !       costz0=costz0-costz3(j2)*(jastrow_ei(r0,vj(pointvj(j2)),iesd)-vold)

                                jastrownb = -costz0b * costz3(j2)
                             voldb_n(j2+nel)=voldb_n(j2+nel)+costz0b*costz3(j2)

                                if(Lbox.gt.0) then
                                    r0 = norm_metric(rc, metric)
!                                   r0o = norm_metric(rco, metric)
                                else
                                    r0 = dsqrt(sum(rc(:)*rc(:)))
!                                   r0o = dsqrt(sum(rco(:)**2))
                                endif
                                r0b = 0.d0
!                               r0ob = 0.d0

                                if(r0.gt.1d-9) then
                                    call jastrow_ei_b(r0, r0b, vj(pointvj(1, j2))&
                                            &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrownb)
                                    rcb(:) = r0b * rc(:) / r0
                                else
                                    rcb = 0.d0
                                endif

!                                if(r0o.gt.1d-9) then
!                                    call jastrow_ei_b(r0o, r0ob, vj(pointvj(1, j2))&
!                                            &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrowob)
!                                    rcob(:) = r0ob * rco(:) / r0o
!                                else
!                                    rcob = 0.d0
!                                endif

                                if(LBox.gt.0.d0) then
                                    !       derivative of the mapping 1
                                    !       rc0(:)=kel(:,j1)+ivic(:,i,j1)-rion(:,j2)
                                    !       call CartesianToCrystal(rc0,1)
                                    !       do kk=1,3
                                    !       rc(kk)=costz(j2)*map(rc0(kk),cellscale(kk))
                                    !       enddo

                                    do kk = 1, 3
                                        rcb(kk) = rcb(kk) * costz(j2)
                                        rc0b(kk) = 0.d0
                          call map_b(rc0(kk), rc0b(kk), cellscale(kk), cellscaleb(kk), rcb(kk))
                                    enddo
                                    call CartesianToCrystal_b(rc0_before, rc0b, car2cryb, 1)
                                    kelb(:, j1) = kelb(:, j1) + rc0b(:)
                                    ivicb(:, i, j1) = ivicb(:, i, j1) + rc0b(:)
                                    rionb(:, j2) = rionb(:, j2) - rc0b(:)
                                    !       derivative of the mapping 2
                                    !       rco0(:)=kel(:,j1)-rion(:,j2)
                                    !       call CartesianToCrystal(rco0,1)
                                    !       do kk=1,3
                                    !       rco(kk)=costz(j2)*map(rco0(kk),cellscale(kk))
                                    !       enddo
!                                    do kk = 1, 3
!                                        rcob(kk) = rcob(kk) * costz(j2)
!                                        rco0b(kk) = 0.d0
!                       call map_b(rco0(kk), rco0b(kk), cellscale(kk), cellscaleb(kk), rcob(kk))
!                                    enddo
!                                    call CartesianToCrystal_b(rco0_before, rco0b, car2cryb, 1)
!                                    kelb(:, j1) = kelb(:, j1) + rco0b(:)
!                                    rionb(:, j2) = rionb(:, j2) - rco0b(:)

                                else

                                kelb(:, j1) = kelb(:, j1) + costz(j2) * rcb(:)
                          ivicb(:, i, j1) = ivicb(:, i, j1) + costz(j2) * rcb(:)
                                rionb(:, j2) = rionb(:, j2) - costz(j2) * rcb(:)

                                endif

                            enddo ! j2

                        endif ! n_body_on =/0


                        !       el-el jastrow 2 body

                        if(n_body_on.eq.0) then

                            costz0 = 0.d0
                            !do for the second particle
                            do j2 = 1, nel



                                if(j2.ne.j1) then

                                    rc(:) = kel(:, j1) + ivic(:, i, j1) - kel(:, j2)

                                    !************* PERIODIC WORLD *********************
                                    if(LBox.gt.0.d0) then
!                                       call CartesianToCrystal(rc, 1)
  rc(:)=car2cry(:,1)*rc(1)+car2cry(:,2)*rc(2)+car2cry(:,3)*rc(3)

                                        do kk = 1, 3
                                            !        rc(kk)=cellpi(kk)*dsin(rc(kk)/cellpi(kk))
                                            rc(kk) = map(rc(kk), cellscale(kk))
                                        enddo
                                    endif
                                    !************* PERIODIC WORLD *********************

                                    costz0 = costz0 + jastrow_ee(rc, vj, iesd, ispin_n(j2)) - vold_n(j2)
                                endif
                            enddo

                        else
                            !       do not repeat the same calculation already done before
                            costz0 = costz0e
                        endif

                        !       do not change tabpip for the next update
                        !       tabpip(j1,i)=tabpip(j1,i)*dexp(costz0)

                        costz0 = dexp(costz0)
                        costz0b = tabpipb(j1, i) * costz0
                        tabpipb(j1, i) = tabpipb(j1, i) * costz0

                        !       back of the loop

                        do j2 = 1, nel


                            if(j2.ne.j1) then

                                rc(:) = kel(:, j1) + ivic(:, i, j1) - kel(:, j2)
!                               rco(:) = kel(:, j1) - kel(:, j2)

                                !************* PERIODIC WORLD *********************
                                if(LBox.gt.0.d0) then
                                    rc_before = rc
!                                   rco_before = rco
!                                   call CartesianToCrystal(rc, 1)
  rc(:)=car2cry(:,1)*rc(1)+car2cry(:,2)*rc(2)+car2cry(:,3)*rc(3)

!                                   call CartesianToCrystal(rco, 1)
! rco(:)=car2cry(:,1)*rco(1)+car2cry(:,2)*rco(2)+car2cry(:,3)*rco(3)

                                    do kk = 1, 3
                                        rc0(kk) = rc(kk)
!                                       rco0(kk) = rco(kk)
!                                       rco(kk) = map(rco0(kk), cellscale(kk))
                                        rc(kk) = map(rc0(kk), cellscale(kk))
                                    enddo
                                endif

                                !       costzb=tabpipb(j1,i)*dexp(costz0)*tabpip(j1,i)
                                !       tabpipb(j1,i)=tabpipb(j1,i)*dexp(costz0)
                                !        reverse of (costz0b unchanged)
                                !        costz0=costz0+jastrow_ee(rc,vj,iesd,ispin)-vold

                                jastrownb = costz0b
!    reverse of costz0 = costz0 + costzj - vold_n(j2)
                                voldb_n(j2)=voldb_n(j2)-costz0b
!                               jastrowob = jastrowob -costz0b

                                rcb = 0.d0
!                               rcob = 0.d0

                          call jastrow_ee_b(rc, rcb, vj, vjb, iesd, ispin_n(j2), jastrownb, metricb)

!                         call jastrow_ee_b(rco, rcob, vj, vjb, iesd, ispin_n(j2), jastrowob, metricb)

                                if(Lbox.gt.0) then
                                    !        reverse of the previous routine
                                    !        do kk=1,3
                                    !        rc0(kk)=rc(kk)
                                    !        rco0(kk)=rco(kk)
                                    !        rco(kk)=map(rco0(kk),cellscale(kk))
                                    !        rc(kk)=map(rc0(kk),cellscale(kk))
                                    !        enddo
                                    do kk = 1, 3
                                        rc0b(kk) = 0.d0
!                                       rco0b(kk) = 0.d0
                       call map_b(rc0(kk), rc0b(kk), cellscale(kk), cellscaleb(kk), rcb(kk))
!                      call map_b(rco0(kk), rco0b(kk), cellscale(kk), cellscaleb(kk), rcob(kk))
                                        rcb(kk) = rc0b(kk)
!                                       rcob(kk) = rco0b(kk)
                                    enddo
                                    call CartesianToCrystal_b(rc_before, rcb, car2cryb, 1)
!                                   call CartesianToCrystal_b(rco_before, rcob, car2cryb, 1)
                                endif


                                !        update kel ivic
                                kelb(:, j1) = kelb(:, j1) + rcb(:) 
                                kelb(:, j2) = kelb(:, j2) - rcb(:) 

                                ivicb(:, i, j1) = ivicb(:, i, j1) + rcb(:)

                            endif ! j1 ne j2
                        enddo ! j2

                    enddo ! end i over the pseudo mesh
                        if(n_body_on.ne.0) then
                            do j2 = 1, nion !do for the second particle

                                if(LBox.gt.0.d0) then
!                                    rc0(:) = kel(:, j1) + ivic(:, i, j1) - rion(:, j2)
!                                    rc0_before(:) = rc0(:)
!                                   call CartesianToCrystal(rc0, 1)
!     rc0(:)=car2cry(:,1)*rc0(1)+car2cry(:,2)*rc0(2)+car2cry(:,3)*rc0(3)
!                                    do kk = 1, 3
!                                        rc(kk) = costz(j2) * map(rc0(kk), cellscale(kk))
!                                    enddo
                                    rco0(:) = kel(:, j1) - rion(:, j2)
                                    rco0_before(:) = rco0(:)
!                                   call CartesianToCrystal(rco0, 1)
  rco0(:)=car2cry(:,1)*rco0(1)+car2cry(:,2)*rco0(2)+car2cry(:,3)*rco0(3)
                                    do kk = 1, 3
                                        rco(kk) = costz(j2) * map(rco0(kk), cellscale(kk))
                                    enddo
                                else
!                                    rc(:) = costz(j2) * (kel(:, j1) + ivic(:, i, j1) - rion(:, j2))
                                    rco(:) = costz(j2) * (kel(:, j1) - rion(:, j2))
                                endif



                                !       reverse of
                                !       tabpip(j1,i)=tabpip(j1,i)*dexp(costz0)
                                !       costz0b=tabpipb(j1,i)*tabpip(j1,i)*dexp(costz0)
                                !       reverse of
                                !       costz0=costz0-costz3(j2)*(jastrow_ei(r0,vj(pointvj(j2)),iesd)-vold)

!                               jastrownb = -costz0b * costz3(j2)

                                if(Lbox.gt.0) then
!                                   r0 = norm_metric(rc, metric)
                                    r0o = norm_metric(rco, metric)
                                else
!                                   r0 = dsqrt(sum(rc(:)**2))
                                    r0o = dsqrt(sum(rco(:)*rco(:)))
                                endif
!                               r0b = 0.d0
                                r0ob = 0.d0

!                                if(r0.gt.1d-9) then
!                                    call jastrow_ei_b(r0, r0b, vj(pointvj(1, j2))&
!                                            &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrownb)
!                                    rcb(:) = r0b * rc(:) / r0
!                                else
!                                    rcb = 0.d0
!                                endif

                                if(r0o.gt.1d-9) then
                                    call jastrow_ei_b(r0o, r0ob, vj(pointvj(1, j2))&
                                            &, vjb(pointvj(1, j2)), pointvj(2, j2), voldb_n(nel+j2))
                                    rcob(:) = r0ob * rco(:) / r0o
                                else
                                    rcob = 0.d0
                                endif

                                if(LBox.gt.0.d0) then
                                    !       derivative of the mapping 1
                                    !       rc0(:)=kel(:,j1)+ivic(:,i,j1)-rion(:,j2)
                                    !       call CartesianToCrystal(rc0,1)
                                    !       do kk=1,3
                                    !       rc(kk)=costz(j2)*map(rc0(kk),cellscale(kk))
                                    !       enddo

!                                    do kk = 1, 3
!                                        rcb(kk) = rcb(kk) * costz(j2)
!                                        rc0b(kk) = 0.d0
!                          call map_b(rc0(kk), rc0b(kk), cellscale(kk), cellscaleb(kk), rcb(kk))
!                                    enddo
!                                    call CartesianToCrystal_b(rc0_before, rc0b, car2cryb, 1)
!                                    kelb(:, j1) = kelb(:, j1) + rc0b(:)
!                                    ivicb(:, i, j1) = ivicb(:, i, j1) + rc0b(:)
!                                    rionb(:, j2) = rionb(:, j2) - rc0b(:)
                                    !       derivative of the mapping 2
                                    !       rco0(:)=kel(:,j1)-rion(:,j2)
                                    !       call CartesianToCrystal(rco0,1)
                                    !       do kk=1,3
                                    !       rco(kk)=costz(j2)*map(rco0(kk),cellscale(kk))
                                    !       enddo
                                    do kk = 1, 3
                                        rcob(kk) = rcob(kk) * costz(j2)
                                        rco0b(kk) = 0.d0
                       call map_b(rco0(kk), rco0b(kk), cellscale(kk), cellscaleb(kk), rcob(kk))
                                    enddo
                                    call CartesianToCrystal_b(rco0_before, rco0b, car2cryb, 1)
                                    kelb(:, j1) = kelb(:, j1) + rco0b(:)
                                    rionb(:, j2) = rionb(:, j2) - rco0b(:)

                                else

                                   kelb(:, j1) = kelb(:, j1) + costz(j2) *  rcob(:)
!                                   ivicb(:, i, j1) = ivicb(:, i, j1) + costz(j2) * rcb(:)
                                    rionb(:, j2) = rionb(:, j2) - costz(j2) * rcob(:)

                                endif

                            enddo ! j2
                        endif
                        do j2 = 1, nel
                            if(j2.ne.j1) then

!                               rc(:) = kel(:, j1) + ivic(:, i, j1) - kel(:, j2)
                                rco(:) = kel(:, j1) - kel(:, j2)

                                !************* PERIODIC WORLD *********************
                                if(LBox.gt.0.d0) then
!                                   rc_before = rc
                                    rco_before = rco
!                                   call CartesianToCrystal(rc, 1)
! rc(:)=car2cry(:,1)*rc(1)+car2cry(:,2)*rc(2)+car2cry(:,3)*rc(3)

!                                   call CartesianToCrystal(rco, 1)
  rco(:)=car2cry(:,1)*rco(1)+car2cry(:,2)*rco(2)+car2cry(:,3)*rco(3)

                                    do kk = 1, 3
!                                       rc0(kk) = rc(kk)
                                        rco0(kk) = rco(kk)
                                        rco(kk) = map(rco0(kk), cellscale(kk))
!                                       rc(kk) = map(rc0(kk), cellscale(kk))
                                    enddo
                                endif

                                !       costzb=tabpipb(j1,i)*dexp(costz0)*tabpip(j1,i)
                                !       tabpipb(j1,i)=tabpipb(j1,i)*dexp(costz0)
                                !        reverse of (costz0b unchanged)
                                !        costz0=costz0+jastrow_ee(rc,vj,iesd,ispin)-vold

!                               jastrownb = costz0b
!                               jastrowob = -costz0b

!                               rcb = 0.d0
                                rcob = 0.d0

!                         call jastrow_ee_b(rc, rcb, vj, vjb, iesd, ispin_n(j2), jastrownb, metricb)

                          call jastrow_ee_b(rco, rcob, vj, vjb, iesd, ispin_n(j2), voldb_n(j2), metricb)

                                if(Lbox.gt.0) then
                                    !        reverse of the previous routine
                                    !        do kk=1,3
                                    !        rc0(kk)=rc(kk)
                                    !        rco0(kk)=rco(kk)
                                    !        rco(kk)=map(rco0(kk),cellscale(kk))
                                    !        rc(kk)=map(rc0(kk),cellscale(kk))
                                    !        enddo
                                    do kk = 1, 3
!                                       rc0b(kk) = 0.d0
                                        rco0b(kk) = 0.d0
!                      call map_b(rc0(kk), rc0b(kk), cellscale(kk), cellscaleb(kk), rcb(kk))
                       call map_b(rco0(kk), rco0b(kk), cellscale(kk), cellscaleb(kk), rcob(kk))
!                                       rcb(kk) = rc0b(kk)
                                        rcob(kk) = rco0b(kk)
                                    enddo
!                                   call CartesianToCrystal_b(rc_before, rcb, car2cryb, 1)
                                    call CartesianToCrystal_b(rco_before, rcob, car2cryb, 1)
                                endif


                                !        update kel ivic
                                kelb(:, j1) = kelb(:, j1) + rcob(:)
                                kelb(:, j2) = kelb(:, j2) - rcob(:)

                            endif ! j1 ne j2
                        enddo ! j2
                enddo !  j1
                !#ifdef __REDUCTION
!$omp end parallel do
            endif ! niesd>0
        endif ! endif ncore gt.0

        if(ieseloc) then
            tabpip(1:nel, indt + 1:indt + 4) = 0.d0
            if(niesd.gt.0) then
                maxii=nel
                maxii=(maxii*(nel-1))/2
#ifndef _SW 
!$omp parallel do default(shared) private(ii,j1,j2,kk,ispin,rc,jastrow1,grad1,grad2,&
!$omp grad1b,grad2b,rcb) reduction(+:kelb,rionb,cellscaleb,metricb,car2cryb,vjb,tabpip)
#else
!$omp parallel do default(shared) private(ii,j1,j2,kk,ispin,rc,jastrow1,grad1,grad2,&
!$omp grad1b,grad2b,rcb) reduction(+:kelb,rionb,cellscaleb,metricb,car2cryb,vjb)
#endif
                do ii=1,maxii
                call find_j1j2(nel,ii,j1,j2) ! to collapse the loop by hand.
!               do j1 = 1, nel
!                   do j2 = 1, nel
!                     if(j2.gt.j1) then  ! for the collapse
                        if(iesiesd) then

                            if((j1.le.nelup.and.j2.le.nelup).or.(j1.gt.nelup.and.j2.gt.nelup)) then
                                ! parallel spins
                                ispin = 1
                            else
                                ispin = -1
                            endif

                        else
                            ispin = -1
                        endif

!                       if(j2.ne.j1) then
! HERE we leave the direct part because the intel compiler fails in threading
!  in a reasonable compiler remove above reduction on tabpip and cut up to THERE
#ifndef _SW 
                             rc(:) = kel(:, j1) - kel(:, j2)

                             if(LBox.gt.0.d0)then
                                 call jastrowgrad_pbc(rc, vj, iesd, jastrow1, grad1, grad2, ispin&
                                         &, 1.d0, LBox)
                             else
                                 call jastrowgrad(rc, vj, iesd, jastrow1, grad1, grad2, ispin)
                             endif

                             do kk = 1, 3
                                 tabpip(j1, indt + kk) = tabpip(j1, indt + kk) + grad1(kk)
                                 tabpip(j2, indt + kk) = tabpip(j2, indt + kk) - grad1(kk)
                             enddo
                             tabpip(j1, indt + 4) = tabpip(j1, indt + 4) + grad2
                             tabpip(j2, indt + 4) = tabpip(j2, indt + 4) + grad2
#endif
                            !       reverse of the above
                            grad2b = tabpipb(j1, indt + 4)+tabpipb(j2, indt + 4)
                            grad1b(1:3) = tabpipb(j1, indt + 1:indt + 3)-tabpipb(j2, indt + 1:indt + 3)

                            rcb = 0.d0
                            rc(:) = kel(:, j1) - kel(:, j2)

                            if(Lbox.gt.0) then
                                !       recompute rc
                 call jastrowgrad_pbc_b(rc, rcb, vj, vjb, iesd, jastrow1, grad1, grad1b&
               &, grad2, grad2b, ispin, 1.d0, cellscaleb, metricb, car2cryb)
                            else
                call jastrowgrad_b(rc, rcb, vj, vjb, iesd, jastrow1, grad1, grad1b&
               &, grad2, grad2b, ispin)
                            endif
                            !        rc(:)=kel(:,j1)-kel(:,j2)
                            kelb(:, j1) = kelb(:, j1) + rcb(:)
                            kelb(:, j2) = kelb(:, j2) - rcb(:)
!                    endif
!                   enddo
                  enddo
!$omp end parallel do
                    if(n_body_on.ne.0) then
!$omp parallel do default(shared) private(j1,j2,kk,rc,jastrow1,grad1,grad2,&
!$omp grad1b,grad2b,rcb) reduction(+:rionb,cellscaleb,metricb,car2cryb,vjb)
                do j1=1,nel
                        do j2 = 1, nion
#ifndef _SW 
                            if(LBox.gt.0.d0) then
                                rc(:) = kel(:, j1) - rion(:, j2)
                                call jastrowgrad_pbc(rc, vj(pointvj(1, j2))&
                                        &, pointvj(2, j2), jastrow1, grad1, grad2, -1, costz(j2), LBox)
                            else
                                rc(:) = (kel(:, j1) - rion(:, j2)) * costz(j2)
                                call jastrowgrad(rc, vj(pointvj(1, j2))&
                                        &, pointvj(2, j2), jastrow1, grad1, grad2, -1)
                            endif

                            do kk = 1, 3
                                tabpip(j1, indt + kk) = tabpip(j1, indt + kk)                        &
                                        & - grad1(kk) * costz(j2) * costz3(j2)
                            enddo

                            tabpip(j1, indt + 4) = tabpip(j1, indt + 4)                             &
                                    & - grad2 * costz(j2)*costz(j2)*costz3(j2)
#endif

                            !          reverse of the above

                            grad2b = -tabpipb(j1, indt + 4) * costz(j2)*costz(j2)*costz3(j2)
                            grad1b(1:3) = -tabpipb(j1, indt + 1:indt + 3) * costz(j2) * costz3(j2)

                            rcb = 0.d0

                            if(LBox.gt.0.d0) then

                                rc(:) = kel(:, j1) - rion(:, j2)


                                call jastrowgrad_pbc_b(rc, rcb, vj(pointvj(1, j2))&
                         &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrow1, grad1&
                         &, grad1b, grad2, grad2b, -1, costz(j2), cellscaleb, metricb, car2cryb)

                                kelb(:, j1) = kelb(:, j1) + rcb(:)
                                rionb(:, j2) = rionb(:, j2) - rcb(:)

                            else

                                rc(:) = (kel(:, j1) - rion(:, j2)) * costz(j2)

                                call jastrowgrad_b(rc, rcb, vj(pointvj(1, j2))&
                                        &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrow1&
                                        &, grad1, grad1b, grad2, grad2b, -1)

                                kelb(:, j1) = kelb(:, j1) + rcb(:) * costz(j2)
                                rionb(:, j2) = rionb(:, j2) - rcb(:) * costz(j2)

                            endif
                        enddo
                enddo
!$omp end parallel do
              endif ! endif n_body_on =/0
            endif ! niesd > 0
        endif  ! endif ieseloc

        !   restore tabpip

        tabpip = tabpipsav

        logpsib(1:ipc) = 0.d0
        tabpipb = 0.d0
    END SUBROUTINE TASK9_B
    !  Differentiation of task1 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: rion kel dist
    !   of linear combination of output variables: rion kel dist
    SUBROUTINE TASK1_B(kel, kelb, rion, rionb, dist, distb, cellscaleb, s2rb)
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: kel(3, nel), rion(3, nion)
        REAL*8 :: kelb(3, nel), rionb(3, nion)
        REAL*8 :: dist(nion, nel)
        REAL*8 :: distb(nion, nel), cellscaleb(3), s2rb(3, 3)
        !   task #1  input kel rion --> output dist el-ion distance to be used later.
        if(ncore.gt.0) then  ! used only with pseudo
!$omp parallel do default(shared) private(i,j) reduction(+:rionb,cellscaleb,s2rb)
            do i = 1, nel
                do j = 1, nion
                    call ngivej_b(kel(:, i), kelb(:, i), rion(:, j), rionb(:, j), Lbox&
                            &, distb(j, i), cellscaleb, s2rb)
                enddo
            enddo
        endif

        distb = 0.d0

    END SUBROUTINE TASK1_B

    !  Differentiation of task2 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: kelind rion kel
    !                prefactor dist
    !   of linear combination of output variables: ivic psip kelind
    !                rion kel prefactor


    SUBROUTINE TASK2_B(kelind, kelindb, rion, rionb, dist, distb, kel, kelb, &
            &vpseudolocal, vpseudolocalb, prefactor, prefactorb, ivic, ivicb, tmu, tmub&
            &, cellscaleb, s2rb, car2cryb, metricb)
        !  Hint: ISIZE1OFpsip should be the size of dimension 1 of array psip
        !  Hint: ISIZE1OFparshell should be the size of dimension 1 of array parshell
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: kelind(3, nel), rion(3, nion), dist(nion, nel)
        REAL*8, INTENT(IN) :: tmu(nel, *)
        REAL*8 :: kelindb(3, nel), rionb(3, nion), distb(nion, nel)
        REAL*8 :: kel(3, nel, 0:indt), vpseudolocal, prefactor(indt - istart + 1&
                &, nel)
        REAL*8 :: kelb(3, nel, 0:indt), prefactorb(indt - istart + 1, nel)
        real*8 :: pseudolocalb, vpseudolocalb, cellscaleb(3)&
                &, s2rb(3, 3), car2cryb(3, 3), metricb(3, 3)
        REAL*8 :: tmub(nel, indt)
        REAL*8 :: ivic(3, indtmax, nel), ivicb(3, indtmax, nel)
        INTEGER :: arg1
        ! choose a random direction (fillmatrix) and compute the integration mesh
        ! randomness can be avoided if
        ! ioptpseudo&iesrandoma=false
        !  input kelind(3,nel), rion,  dist(nel,nion) --->
        !  output:
        !  kel(3,j,1:indtm(j)) j=1,nel  integration mesh pseudo
        !  ivic (same information as above) used later.
        !  vpseudolocal  (scalar)            local part potential due to pseudo
        !  prefactor(indt-istart+1,nel)  information about non local part to be
        !  computed later
        if(lrdmc_deru) then
            !         do j=1,nel
            !            do i=1,istart-1
            !               do kk=1,3
            !                  kel(kk,j,i)=kelind(kk,j)+ivic(kk,i,j)
            !               enddo
            !            enddo
            !         enddo

            do j = 1, nel
                do i = 1, istart - 1
                    call lrdmc(kelind(1, j), kelindb(1, j), nion, rion, rionb, i, alat, ivic(1, 1, j)&
                            &, plat, cellscale, cellscaleb, s2r, s2rb, iespbc, tmub(j, i))
                enddo
            enddo

            !    do j=1,nel
            !       do i=1,istart-1
            !       tmu(j,i)=t_lrdmc(kel(1,j,i),nion,rion,i,alat,ivic(1,1,j),plat,cellscale,iespbc)
            !       enddo
            !    enddo

            do j = 1, nel
                DO i = 1, istart - 1
                    DO kk = 1, 3
                        kelindb(kk, j) = kelindb(kk, j) + kelb(kk, j, i)
                        ivicb(kk, i, j) = ivicb(kk, i, j) + kelb(kk, j, i)
                        kelb(kk, j, i) = 0.0_8
                    END DO
                enddo
            enddo

        endif

        IF (ncore .GT. 0) THEN
            arg1 = indt - istart + 1

            !  Updating prefactorb given tmub
            do j = 1, nel
                do i = istart, indtm(j)
                    prefactorb(i - istart + 1, j) = prefactorb(i - istart + 1, j) - tmub(j, i)
                    tmub(j, i) = 0.d0
                enddo
            enddo

            do j = 1, nel
                DO i = istart, indtm(j)
                    DO kk = 1, 3
                        kelindb(kk, j) = kelindb(kk, j) + kelb(kk, j, i)
                        ivicb(kk, i, j) = ivicb(kk, i, j) + kelb(kk, j, i)
                        kelb(kk, j, i) = 0.0_8
                    END DO
                enddo
                pseudolocalb = vpseudolocalb



                !     CALL POPREAL8ARRAY(wpseudo, 2*lmax)
                !     initialize the vectors  used only here
                wpseudob = 0.d0
                legendreb = 0.d0
                !     psipb=0.d0 not necessary initialized in pseudofun_b

                CALL PSEUDOSET_B(j, kelind(1, j), kelindb(1, j), ivic(1, istart, j)&
                        &, ivicb(1, istart, j), prefactor, prefactorb, &
                        pseudolocal(j), pseudolocalb, nion, nintpseudo, dist, distb, rcutoff, &
                        &                 kindion, rion, rionb, pshell, nparpshell, parshell, &
                        &                 lmax, wpseudo, wpseudob, legendre, legendreb&
                        &, versor, wintpseudo, jpseudo, ncore, arg1, indtm(j), &
                        &            .false., angle(10, j), psip, psipb, lbox, 1d-9, iflag, cellscaleb, s2rb, car2cryb)

                !      if(iflag.ne.0) return no need already done.

            enddo

            ! Output
            ! prefactorb=0.d0
            vpseudolocalb = 0.d0
            ! ivicb=0.d0
            ! kelb(:,:,1:indt)=0.d0

        END IF

    END SUBROUTINE TASK2_B


    !  Differentiation of task4 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: rion psip kel
    !   of linear combination of output variables: dd vju cnorm r rion
    !                rmusin rmucos rmu zeta psip winvj winv kel

    SUBROUTINE TASK4_B(kel, kelb, rion, rionb, dd, ddb, vju, vjub, winv, winvb, winvj, winvjb, cellscaleb, s2rb)
        !  Hint: ISIZE1OFcnorm should be the size of dimension 1 of array cnorm
        !  Hint: ISIZE1OFpsip should be the size of dimension 1 of array psip
        !  Hint: ISIZE1OFdd should be the size of dimension 1 of array dd
        !  Hint: ISIZE1OFvju should be the size of dimension 1 of array vju
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: kel(3, nel, 0:indt)
        REAL*8 :: kelb(3, nel, 0:indt)
        REAL*8 :: rion(3, nion), rionb(3, nion)
        REAL*8 :: winv(ipc * nelorb, 0:indt4, nel), winvj(nelorbjmax, 0:indt4j, nel)
        REAL*8 :: winvb(ipc * nelorb, 0:0, nel), winvjb(nelorbjmax, 0:0, nel)
        REAL*8 :: cellscaleb(3), s2rb(3, 3)
        REAL*8 :: dd(*), ddb(*), vju(*), vjub(*)
        !     evaluation gradients and laplacians of orbitals in the electron
        !     positions kel (with pseudo also in the mesh).
        !     input  kel(3,nel,1:indt)
        !     output winv(nelorb,nel,indt+4),winvj(nelorbj,nel,indtj+4)
        !     all the rest is not used later.
        !      call dscalzero(nelorb5*nel,0.d0,winv,1)
        !      if(nelorbj.gt.0) call dscalzero(nelorbj5*nel,0.d0,winvj,1)
        integer indtm_max,indtmu

      if(donebig) then

        if(ncore.gt.0.or.lrdmc_deru) then
        indtm_max=indt
        else
        indtm_max=0
        endif


        if(yesforce.or.yeszagp) then
        winvb_big(:,0,1:nel)=winvb_big(:,0,1:nel)+winvb(:,0,1:nel)
        winvb(:,0,1:nel)=0.d0
        endif
        if(nelorbj.gt.0.and.(yesforce.or.yeszj)) then 
        winvjb_big(:,0,1:nel)=winvjb_big(:,0,1:nel)+winvjb(:,0,1:nel)
        winvjb(:,0,1:nel)=0.d0
        endif
        yesupel = .false.
        DO j = nelup + 1, nel

            indtmu=min(indtm_max,indtm(j))

            if(yesforce.or.yeszagp) then

                CALL UPNEWWF_B(indt, 0, indtmu, 0, nshelldoh, ioptorb, ioccdo, kel(1, j, 0)&
                        &, kelb(1, j, 0), nel, r, rb, rmu, rmub, dd, ddb, zeta, &
                        &               rion, rionb, psip, psipb, winv(1, 0, j), winvb_big(1&
                                &, 0, j), nelorb, nion, kion, iflagnorm, cnorm, &
                        & lbox, rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &          indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)



                !     iflagnorm=-abs(iflagnorm)

            endif

            IF (nelorbj.ne.0.and.(yesforce.or.yeszj)) THEN
                CALL UPNEWWF_B(indt, 0, indtmu, 0, nshelljh, ioptorbj, ioccj, kel(1, j, 0&
                        &), kelb(1, j, 0), nel, r, rb, rmu, rmub, vju, vjub, &
                        &                 zeta, rion, rionb, psip, psipb, winvj(1, 0, j)&
                        &, winvjb_big(1, 0, j), nelorbj, nion, kionj, iflagnorm, &
                        &                 cnorm(nshell + 1), lbox, rmucos, &
                        &rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &                 indparj_tab, indorbj_tab, indshellj_tab, adrj_nion, indj_nion)
                !     else
                !     iflagnorm=abs(iflagnorm)
            END IF

        END DO
        yesupel = .true.
        DO j = 1, nelup
            indtmu=min(indtm_max,indtm(j))
            if(yesforce.or.yeszagp) then
                CALL UPNEWWF_B(indt, 0, indtmu, 0, nshellh, ioptorb, ioccup, kel(1, j, 0), &
                        &               kelb(1, j, 0), nel, r, rb, rmu, rmub, dd, ddb, zeta, &
                        &               rion, rionb, psip, psipb, winv(1, 0, j), winvb_big(1&
                                &, 0, j), nelorb, nion, kion, iflagnorm, cnorm, &
                        &lbox, rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &      indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)
                !     iflagnorm=-abs(iflagnorm)
            endif
            IF (nelorbj.ne.0.and.(yesforce.or.yeszj)) THEN
                CALL UPNEWWF_B(indt, 0, indtmu, 0, nshelljh, ioptorbj, ioccj, kel(1, j, 0&
                        &), kelb(1, j, 0), nel, r, rb, rmu, rmub, vju, vjub, &
                        &                 zeta, rion, rionb, psip, psipb, winvj(1, 0, j)&
                        &, winvjb_big(1, 0, j), nelorbj, nion, kionj, iflagnorm, &
                        &                 cnorm(nshell + 1), lbox, rmucos, &
                        &rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &                 indparj_tab, indorbj_tab, indshellj_tab, adrj_nion, indj_nion)
                !     else
                !     iflagnorm=abs(iflagnorm)
            END IF
        END DO



      else

        yesupel = .false.
        DO j = nelup + 1, nel

            if(yesforce.or.yeszagp) then

                CALL UPNEWWF_B(0, 0, 0, 1, nshelldoh, ioptorb, ioccdo, kel(1, j, 0)&
                        &, kelb(1, j, 0), nel, r, rb, rmu, rmub, dd, ddb, zeta, &
                        &               rion, rionb, psip, psipb, winv(1, 0, j), winvb(1&
                                &, 0, j), nelorb, nion, kion, iflagnorm, cnorm, &
                        & lbox, rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &          indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)



                !     iflagnorm=-abs(iflagnorm)

            endif

            IF (nelorbj.ne.0.and.(yesforce.or.yeszj)) THEN
                CALL UPNEWWF_B(0, 0, 0, 1, nshelljh, ioptorbj, ioccj, kel(1, j, 0&
                        &), kelb(1, j, 0), nel, r, rb, rmu, rmub, vju, vjub, &
                        &                 zeta, rion, rionb, psip, psipb, winvj(1, 0, j)&
                        &, winvjb(1, 0, j), nelorbj, nion, kionj, iflagnorm, &
                        &                 cnorm(nshell + 1), lbox, rmucos, &
                        &rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &                 indparj_tab, indorbj_tab, indshellj_tab, adrj_nion, indj_nion)
                !     else
                !     iflagnorm=abs(iflagnorm)
            END IF

        END DO

        DO j = 1, nelup
            yesupel = .true.
            if(yesforce.or.yeszagp) then
                CALL UPNEWWF_B(0, 0, 0, 1, nshellh, ioptorb, ioccup, kel(1, j, 0), &
                        &               kelb(1, j, 0), nel, r, rb, rmu, rmub, dd, ddb, zeta, &
                        &               rion, rionb, psip, psipb, winv(1, 0, j), winvb(1&
                                &, 0, j), nelorb, nion, kion, iflagnorm, cnorm, &
                        &lbox, rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &      indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)
                !     iflagnorm=-abs(iflagnorm)
            endif
            IF (nelorbj.ne.0.and.(yesforce.or.yeszj)) THEN
                CALL UPNEWWF_B(0, 0, 0, 1, nshelljh, ioptorbj, ioccj, kel(1, j, 0&
                        &), kelb(1, j, 0), nel, r, rb, rmu, rmub, vju, vjub, &
                        &                 zeta, rion, rionb, psip, psipb, winvj(1, 0, j)&
                        &, winvjb(1, 0, j), nelorbj, nion, kionj, iflagnorm, &
                        &                 cnorm(nshell + 1), lbox, rmucos, &
                        &rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                        &                 indparj_tab, indorbj_tab, indshellj_tab, adrj_nion, indj_nion)
                !     else
                !     iflagnorm=abs(iflagnorm)
            END IF
        END DO
     endif
    END SUBROUTINE TASK4_B

    !  Differentiation of task5 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: psip winvjbarsz
    !                winvj winv winvjbar
    !   of linear combination of output variables: psip winvjbarsz
    !                winvj winvbar winv winvjbar
    SUBROUTINE TASK5_B(winv, winvb, winvj, winvjb, jasmat, jasmatb, jasmatsz, jasmatszb &
            &, muj_c, muj_cb, jasmat_c, jasmat_cb, jasmatsz_c, jasmatsz_cb &
            &, detmat, detmatb, mu_c, mu_cb, detmat_c, detmat_cb, winvbar, winvbarb, &
            &    winvjbar, winvjbarb, winvjbarsz, winvjbarszb)
        IMPLICIT NONE
        !        call dcopy(nelorbh,projm(nelorbh*(nelorb_c+i-1)+1),1&
        !    &,winvbar(1,nel+i),1)
        REAL*8, INTENT(IN) :: winv(ipc * nelorb, 0:indt4, nel), winvj(nelorbjmax, 0:indt4j&
                &, nel)
        REAL*8 :: winvb(ipc * nelorb, 0:0, nel), winvjb(nelorbjmax, 0:0, nel)
        REAL*8 :: winvbar(ipc * ipf * nelorbh, nel_mat), winvjbar(*), &
                &    winvjbarsz(sizewsz)
        REAL*8 :: winvbarb(ipc * ipf * nelorbh, nel_mat), winvjbarb(int(ipj * nelorbjh,8)*nel + 1), &
                &    winvjbarszb(sizewsz)
        REAL*8 :: jasmat(*), jasmatb(dim_jasmat), jasmatsz(*), jasmatszb(*) &
                &, detmat(ipc * ipf * nelorbh, *), detmatb(ipc * ipf * nelorbh, *), mu_c(*), mu_cb(*)&
                &, detmat_c(*), detmat_cb(*)&
                &, muj_c(*), muj_cb(*), jasmat_c(*), jasmat_cb(*), jasmatsz_c(*), jasmatsz_cb(*)
        integer n2p1, firstmdet
        integer*8 indw
        ! to speed up the calculation introduced winvbar and winjbar
        ! input winv, winvj
        ! output winvbar and winvjbar (in terms of detmat and jasmat given
        ! input not changing) winvjbarsz (if spin Jastrow on)
        !       Evaluation of winvbar

        if(ndiff.ne.0.and.yesdodet) then
            if(yesfast.eq.0) then
                do i = 1, ndiff
                    !        winvbar(1:nelorbh,nel+i)=detmat(1:nelorbh,nelorbh+i)
                    detmatb(1:ipc * ipf * nelorbh, ipf * nelorbh + i) = detmatb(1:ipc * ipf * nelorbh, nelorbh * ipf + i) + &
                            & winvbarb(1:ipc * ipf * nelorbh, nel + i)
                    !        call dcopy(nelorbh,detmat(1,nelorbh+i),1,winvbar(1,nel+i),1)
                enddo
            else
                if(ipc.eq.2) then
                    n2p1 = 2 * nelorb_c * nelorb_c + 1
                    call ZGEMM_B('N', 'N', ipf * nelorbh, ndiff, nelorb_c, zone, mu_c, ipf * nelorbh, mu_cb, ipf * nelorbh&
                            &, detmat_c(n2p1), nelorb_c, detmat_cb(n2p1), nelorb_c, zzero, winvbarb(1, nel + 1), ipf * nelorbh)
                else
                    n2p1 = nelorb_c * nelorb_c + 1
                    call DGEMM_B('N', 'N', ipf * nelorbh, ndiff, nelorb_c, 1.d0, mu_c, ipf * nelorbh, mu_cb, ipf * nelorbh&
                            &, detmat_c(n2p1), nelorb_c, detmat_cb(n2p1), nelorb_c, 0.d0, winvbarb(1, nel + 1)&
                            &, ipf * nelorbh)
                endif
                !               do i=1,ndiff
                !     projmb(nelorbh*(nelorb_c+i-1)+1:nelorbh*(nelorb_c+i))=&
                !     &projmb(nelorbh*(nelorb_c+i-1)+1:nelorbh*(nelorb_c+i))+&
                !     &winvbarb(1:nelorbh,nel+i)
                !               enddo

            endif
        endif

        IF (nelorbj.ne.0) THEN

            if(yesfastj.eq.0) then
                if(iessz) then
                    !     input winvjbarszb out winvjb, jasmatsz and winvj known

#ifdef  _OFFLOAD
!$omp target data map(to:winvjbarszb(1:nelorbjh*nel),jasmatsz(1:nelorbjh2o)) map(jasmatszb(1:nelorbjh2o))
#endif


                    CALL DGEMM_B('N', 'N', nelorbjh, nel, nelorbjh, 1.d0, jasmatsz, &
                            &             nelorbjh, jasmatszb, nelorbjh, winvj, nelorbj5, winvjb, &
                            !&             psip, nelorbjh, winvj(1, 0, 1), winvjb(1, 0, 1), &
                            &             nelorbjh, 0.d0, winvjbarszb, nelorbjh)
#ifdef _OFFLOAD
!$omp end target data
#endif
                END IF
                !     input winvjbarb out winvjb, jasmat and winvj known

              if(yes_sparse) then
! It is not necessary to copy the variable below in the cpu, as they are 
! consistent with the ones in the target  at this point.
!#ifdef  _OFFLOAD
!!$omp target update from (jasmatb(1:nnozeroj),winvjb,winvjbarb)
!#endif
                if(ipj.eq.2) then
!$omp parallel do default(shared) private(i,j,ix,iy,indw) reduction(+:jasmatb)
                  do j=1,nelup
                   do i=1,nnozeroj
                    iy=nozeroj(i+nnozeroj)
                    ix=nozeroj(i)
!    if(iy.le.nelorbjh) winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(iy,0,j)
                     if(iy.le.nelorbjh) then
                     indw=int(j-1,8)*nelorbjh2+ix
                     jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(iy,0,j)
                     winvjb(iy,0,j)=winvjb(iy,0,j)+winvjbarb(indw)*jasmat(i)
                     endif
                     if(ix.ne.iy.and.ix.le.nelorbjh) then
                     indw=int(j-1,8)*nelorbjh2+iy
!                    winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(ix,0,j)
                     jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(ix,0,j)
                     winvjb(ix,0,j)=winvjb(ix,0,j)+winvjbarb(indw)*jasmat(i)
                     endif
                   enddo
                  enddo
!$omp parallel do default(shared) private(i,j,ix,iy,indw) reduction(+:jasmatb)
                  do j=nelup+1,nel
                   do i=1,nnozeroj
                    iy=nozeroj(i+nnozeroj)
                    ix=nozeroj(i)
     if(iy.gt.nelorbjh)  then 
                    indw=int(j-1,8)*nelorbjh2+ix
!     winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(iy-nelorbjh,0,j)
      jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(iy-nelorbjh,0,j)
      winvjb(iy-nelorbjh,0,j)=winvjb(iy-nelorbjh,0,j)+winvjbarb(indw)*jasmat(i)
     endif
                     if(ix.ne.iy.and.ix.gt.nelorbjh) then
                     indw=int(j-1,8)*nelorbjh2+iy
!         winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(ix-nelorbjh,0,j+nelup)
      jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(ix-nelorbjh,0,j)
      winvjb(ix-nelorbjh,0,j)=winvjb(ix-nelorbjh,0,j)+winvjbarb(indw)*jasmat(i)
                     endif
                    enddo
                  enddo
                else
!$omp parallel do default(shared) private(i,j,ix,iy,indw) reduction(+:jasmatb)
                  do j=1,nel
                    do i=1,nnozeroj
                    iy=nozeroj(i+nnozeroj)
                    ix=nozeroj(i)
                    indw=int(j-1,8)*nelorbjh+ix
!                   winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(iy,0,j)
                 jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(iy,0,j)
                 winvjb(iy,0,j)=winvjb(iy,0,j)+winvjbarb(indw)*jasmat(i)
                     if(ix.ne.iy) then
                     indw=int(j-1,8)*nelorbjh+iy
!                    winvjbar(indw)=winvjbar(indw)+jasmat(i)*winvj(ix,0,j)
                 jasmatb(i)=jasmatb(i)+winvjbarb(indw)*winvj(ix,0,j)
                 winvjb(ix,0,j)=winvjb(ix,0,j)+winvjbarb(indw)*jasmat(i)
                     endif
                    enddo
                  enddo
                endif            
              winvjbarb=0.d0
#ifdef  _OFFLOAD
!$omp target update to (jasmatb,winvjb,winvjbarb)
#endif
              else

                if (ipj==2) then
                    call DGEMM_B('N', 'N', nelorbju, neldo, nelorbjh, 1.d0, jasmat(nelorbju * nelorbjh + 1), nelorbju, jasmatb(nelorbju * nelorbjh + 1), nelorbju&
                            &, winvj(1, 0, nelup1), nelorbj5, winvjb(1, 0, nelup1), nelorbjh, 0.d0, winvjbarb(zerop1 + nelorbju * nelup), nelorbju)
                endif

                CALL DGEMM_B('N', 'N', nelorbju, nelused, nelorbjh, 1.d0, jasmat, &
                        &           nelorbju, jasmatb, nelorbju, winvj, nelorbj5, winvjb, nelorbjh&


                        &, 0.d0, winvjbarb, nelorbju)
              endif


            else

                call dgemm_('T', 'N', nelorbj_c, nelused, nelorbjh, 1.d0, muj_c, nelorbjh&
                        &, winvj, nelorbj5, 0.d0, psip(nelorbjcp), nelorbj_c)
                call dgemm_('N', 'N', nelorbj_c, nelused, nelorbj_c, 1.d0, jasmat_c, ipj * nelorbj_c&
                        &, psip(nelorbjcp), nelorbj_c, 0.d0, psip, nelorbj_c)

                call dscalzero_(2*nelorbjc,0.d0,psipb,1)

!               psipb(1:2 * nelorbjc) = 0.d0

                CALL DGEMM_B('N', 'N', nelorbjh, nelused, nelorbj_c, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                        &, psip, nelorbj_c, psipb, nelorbj_c, 0.d0, winvjbarb, ipj * nelorbjh)

                CALL DGEMM_B('N', 'N', nelorbj_c, nelused, nelorbj_c, 1.d0, jasmat_c, ipj * nelorbj_c, jasmat_cb&
                        &, ipj * nelorbj_c, psip(nelorbjcp), nelorbj_c, psipb(nelorbjcp), nelorbj_c, 0.d0, psipb, nelorbj_c)

                CALL DGEMM_B('T', 'N', nelorbj_c, nelused, nelorbjh, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                        &, winvj, nelorbj5, winvjb, nelorbjh, 0.d0, psipb(nelorbjcp), nelorbj_c)

                if (ipj==2) then

                    !down-up

                    call dgemm_('N', 'N', nelorbj_c, nelup, nelorbj_c, 1.d0, jasmat_c(1 + nelorbj_c), 2 * nelorbj_c&
                            &, psip(nelorbjcp), nelorbj_c, 0.d0, psip, nelorbj_c)
!                   psipb(1:2 * nelorbjc) = 0.d0
                call dscalzero_(2*nelorbjc,0.d0,psipb,1)

                    CALL DGEMM_B('N', 'N', nelorbjh, nelup, nelorbj_c, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, psip, nelorbj_c, psipb, nelorbj_c, 0.d0, winvjbarb(1 + nelorbjh), 2 * nelorbjh)

                    CALL DGEMM_B('N', 'N', nelorbj_c, nelup, nelorbj_c, 1.d0, jasmat_c(1 + nelorbj_c), 2 * nelorbj_c, jasmat_cb(1 + nelorbj_c)&
                            &, 2 * nelorbj_c, psip(nelorbjcp), nelorbj_c, psipb(nelorbjcp), nelorbj_c, 0.d0, psipb, nelorbj_c)

                    CALL DGEMM_B('T', 'N', nelorbj_c, nelup, nelorbjh, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, winvj, nelorbj5, winvjb, nelorbjh, 0.d0, psipb(nelorbjcp), nelorbj_c)

                    !up-down
                    call dgemm_('T', 'N', nelorbj_c, neldo, nelorbjh, 1.d0, muj_c, nelorbjh&
                            &, winvj(1, 0, nelup1), nelorbj5, 0.d0, psip(nelorbjcp), nelorbj_c)
                    call dgemm_('N', 'N', nelorbj_c, neldo, nelorbj_c, 1.d0, jasmat_c(1 + 2 * nelorbj_c * nelorbj_c), 2 * nelorbj_c&
                            &, psip(nelorbjcp), nelorbj_c, 0.d0, psip, nelorbj_c)
!                   psipb(1:2 * nelorbjc) = 0.d0
                call dscalzero_(2*nelorbjc,0.d0,psipb,1)

                    CALL DGEMM_B('N', 'N', nelorbjh, neldo, nelorbj_c, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, psip, nelorbj_c, psipb, nelorbj_c, 0.d0, winvjbarb(zerop1 + nelorbju * nelup), 2 * nelorbjh)

                    CALL DGEMM_B('N', 'N', nelorbj_c, neldo, nelorbj_c, 1.d0, jasmat_c(1 + 2 * nelorbj_c * nelorbj_c), 2 * nelorbj_c, jasmat_cb(1 + 2 * nelorbj_c * nelorbj_c)&
                            &, 2 * nelorbj_c, psip(nelorbjcp), nelorbj_c, psipb(nelorbjcp), nelorbj_c, 0.d0, psipb, nelorbj_c)

                    CALL DGEMM_B('T', 'N', nelorbj_c, neldo, nelorbjh, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, winvj(1, 0, nelup1), nelorbj5, winvjb(1, 0, nelup1), nelorbjh, 0.d0, psipb(nelorbjcp), nelorbj_c)

                    !down-down

                    call dgemm_('N', 'N', nelorbj_c, neldo, nelorbj_c, 1.d0, jasmat_c(1 + 2 * nelorbj_c * nelorbj_c + nelorbj_c), 2 * nelorbj_c&
                            &, psip(nelorbjcp), nelorbj_c, 0.d0, psip, nelorbj_c)
!                   psipb(1:2 * nelorbjc) = 0.d0
                call dscalzero_(2*nelorbjc,0.d0,psipb,1)

                    CALL DGEMM_B('N', 'N', nelorbjh, neldo, nelorbj_c, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, psip, nelorbj_c, psipb, nelorbj_c, 0.d0, winvjbarb(zerop1 + nelup * nelorbju + nelorbjh), 2 * nelorbjh)

                    CALL DGEMM_B('N', 'N', nelorbj_c, neldo, nelorbj_c, 1.d0, jasmat_c(1 + 2 * nelorbj_c * nelorbj_c + nelorbj_c), 2 * nelorbj_c, jasmat_cb(1 + 2 * nelorbj_c * nelorbj_c + nelorbj_c)&
                            &, 2 * nelorbj_c, psip(nelorbjcp), nelorbj_c, psipb(nelorbjcp), nelorbj_c, 0.d0, psipb, nelorbj_c)

                    CALL DGEMM_B('T', 'N', nelorbj_c, neldo, nelorbjh, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, winvj(1, 0, nelup1), nelorbj5, winvjb(1, 0, nelup1), nelorbjh, 0.d0, psipb(nelorbjcp), nelorbj_c)

                endif

                if(iessz) then
#ifdef  _OFFLOAD
!$omp target data map(to:winvjbarszb(1:nelorbjh*nel),jasmatsz_c(1:nelorbj_c2),muj_c(1:dimmujc)) map(muj_cb(1:dimmujc),jasmatsz_cb(1:nelorbj_c2))
#endif

                    !       call dgemm('T','N',nelorbj_c,nel,nelorbjh,1.d0,muj_c,nelorbjh&
                    !    &,winvj,nelorbj5,0.d0,psip(nelorbjcp),nelorbj_c)
                    !OPT    one can save also this matrix (output of dgemm) nelorbj_cx nel
                    call dgemm_('N', 'N', nelorbj_c, nel, nelorbj_c, 1.d0, jasmatsz_c, nelorbj_c&
                            &, psip(nelorbjcp), nelorbj_c, 0.d0, psip, nelorbj_c)

                    call dscalzero_(2*nelorbjc,0.d0,psipb,1)  

                    CALL DGEMM_B('N', 'N', nelorbjh, nel, nelorbj_c, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, psip, nelorbj_c, psipb, nelorbj_c, 0.d0, winvjbarszb, nelorbjh)

                    CALL DGEMM_B('N', 'N', nelorbj_c, nel, nelorbj_c, 1.d0, jasmatsz_c, nelorbj_c, jasmatsz_cb&
                            &, nelorbj_c, psip(nelorbjcp), nelorbj_c, psipb(nelorbjcp), nelorbj_c, 0.d0, psipb, nelorbj_c)

                    CALL DGEMM_B('T', 'N', nelorbj_c, nel, nelorbjh, 1.d0, muj_c, nelorbjh, muj_cb, nelorbjh&
                            &, winvj, nelorbj5, winvjb, nelorbjh, 0.d0, psipb(nelorbjcp), nelorbj_c)
#ifdef _OFFLOAD
!$omp end target data
#endif

                endif ! end iessz
            endif ! end yesfastj
        endif  ! end nelorbj

        if(yesdodet) then

            IF (yesfast.eq.0) THEN
                !     input detmat winv winvbarb out winvb
                if(ipc.eq.2) then
                    if(ipf.eq.2) then
                        CALL ZGEMM_B('N', 'N', 2 * nelorbh, nelup, nelorbh, zone, detmat, 2 * nelorbh&
                                &, detmatb, 2 * nelorbh, winv, nelorb5, winvb, nelorbh, zzero, winvbarb, 2 * nelorbh)
                        CALL ZGEMM_B('N', 'N', 2 * nelorbh, neldo, nelorbh, zone, detmat(1, nelorbh + 1)&
                                &, 2 * nelorbh, detmatb(1, nelorbh + 1), 2 * nelorbh, winv(1, 0, nelup1), nelorb5&
                                &, winvb(1, 0, nelup1), nelorbh, zzero, winvbarb(1, nelup1), 2 * nelorbh)
                    else
                        CALL ZGEMM_B('T', 'N', nelorbh, nelup, nelorbh, zone, detmat, nelorbh &
                                &, detmatb, nelorbh, winv, nelorb5, winvb, nelorbh, zzero, winvbarb, nelorbh)
                        CALL ZGEMM_B('N', 'N', nelorbh, neldo, nelorbh, zone, detmat, nelorbh&
                                &, detmatb, nelorbh, winv(1, 0, nelup1), nelorb5, winvb(1, 0, nelup1)&
                                &, nelorbh, zzero, winvbarb(1, nelup1), nelorbh)
                    endif
                else
                    if(ipf.eq.2) then
                        CALL DGEMM_B('N', 'N', 2 * nelorbh, nelup, nelorbh, 1.d0, detmat &
                                &, 2 * nelorbh, detmatb, 2 * nelorbh, winv, nelorb5, winvb, nelorbh, 0.d0, &
                                &             winvbarb, 2 * nelorbh)
                        CALL DGEMM_B('N', 'N', 2 * nelorbh, neldo, nelorbh, 1.d0, detmat(1, nelorbh + 1)&
                                &, 2 * nelorbh, detmatb(1, nelorbh + 1), 2 * nelorbh, winv(1, 0, nelup1), nelorb5&
                                &, winvb(1, 0, nelup1), nelorbh, 0.d0, winvbarb(1, nelup1), 2 * nelorbh)
                    else
                        CALL DGEMM_B('T', 'N', nelorbh, nelup, nelorbh, 1.d0, detmat &
                                &, nelorbh, detmatb, nelorbh, winv, nelorb5, winvb, nelorbh, 0.d0, &
                                &             winvbarb, nelorbh)
                        CALL DGEMM_B('N', 'N', nelorbh, neldo, nelorbh, 1.d0, detmat, nelorbh &
                                &, detmatb, nelorbh, winv(1, 0, nelup1), nelorb5, winvb(1, 0, nelup1)&
                                &, nelorbh, 0.d0, winvbarb(1, nelup1), nelorbh)
                    endif
                endif
            ELSE

                firstmmu = (firstmol - 1) * nelorbh * ipc * ipf + 1
                firstmdet = (firstmol - 1) * nelorb_c * ipc + ipc * (firstmol - 1) + 1

                !      recomputing psip
                if(ipf.eq.1) then
                    if(ipc.eq.2) then

                        !OPT   save matrices psip  2xnmolxnelup complex number
                        call zgemm_('T', 'N', nmol, nelup, nelorbh, zone, mu_c(firstmmu), nelorbh&
                                &, winv, nelorb5, zzero, psip(2 * nmol * nelup + 1), nmol)
                        call zgemm_('T', 'N', nmol, nelup, nmol, zone, detmat_c(firstmdet), nelorb_c&
                                &, psip(2 * nmol * nelup + 1), nmol, zzero, psip, nmol)

!                       psipb(1:4 * nmol * nelup) = 0.d0
                        call dscalzero_(4*nmol*nelup,0.d0,psipb,1) 
                        !  Here we assume the direct algorithm in the case yerprojm=.false.
                        !  so winvbar is m_c detmat_c mu_c^T
                        CALL ZGEMM_B('N', 'N', nelorbh, nelup, nmol, zone, mu_c(firstmmu)&
                                &, nelorbh, mu_cb(firstmmu), nelorbh, psip, nmol, psipb, nmol, zzero, &
                                &             winvbarb, nelorbh)

                        CALL ZGEMM_B('T', 'N', nmol, nelup, nmol, zone, detmat_c(firstmdet), nelorb_c&
                                &, detmat_cb(firstmdet), nelorb_c, psip(2 * nmol * nelup + 1), nmol, psipb(2 * nmol * nelup + 1), nmol&
                                &, zzero, psipb, nmol)

                        CALL ZGEMM_B('T', 'N', nmol, nelup, nelorbh, zone, mu_c(firstmmu), nelorbh, mu_cb(firstmmu)&
                                &, nelorbh, winv, nelorb5, winvb, nelorbh, zzero, psipb(2 * nmol * nelup + 1), nmol)

                    else

                        !OPT   save matrices psip  2xnmolxnelup real  number
                        call dgemm_('T', 'N', nmol, nelup, nelorbh, 1.d0, mu_c(firstmmu), nelorbh&
                                &, winv, nelorb5, 0.d0, psip(nmol * nelup + 1), nmol)
                        call dgemm_('T', 'N', nmol, nelup, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, psip(nmol * nelup + 1), nmol, 0.d0, psip, nmol)

!                       psipb(1:2 * nmol * nelup) = 0.d0
                        call dscalzero_(2*nmol*nelup,0.d0,psipb,1) 

                        CALL DGEMM_B('N', 'N', nelorbh, nelup, nmol, 1.d0, mu_c(firstmmu)&
                                &, nelorbh, mu_cb(firstmmu), nelorbh, psip, nmol, psipb, nmol, 0.d0, &
                                &             winvbarb, nelorbh)

                        CALL DGEMM_B('T', 'N', nmol, nelup, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, detmat_cb(firstmdet), nelorb_c, psip(nmol * nelup + 1), nmol, psipb(nmol * nelup + 1), nmol, 0.d0&
                                &, psipb, nmol)

                        CALL DGEMM_B('T', 'N', nmol, nelup, nelorbh, 1.d0, mu_c(firstmmu), nelorbh, mu_cb(firstmmu)&
                                &, nelorbh, winv, nelorb5, winvb, nelorbh, 0.d0, psipb(nmol * nelup + 1), nmol)

                    endif

                endif ! endif ipf
                !      recomputing psip

                !        call dgemm('T','N',nmol,neldo,nelorbh,1.d0,mu_c(firstmmu),nelorbh&
                !     &,winv(1,0,nelup+1),nelorb5,0.d0,psip,nmol)
                if(ipc.eq.2) then
                    !OPT   save matrices psip  2xnmolxneldo complex number
                    if (ipf.eq.2) then
                        call zgemm_('T', 'N', nmol, nelup, nelorbh, zone, mu_c(firstmmu), 2 * nelorbh&
                                &, winv, nelorb5, zzero, psip(2 * nmol * nelup_mat + 1), nmol)
                        call zgemm_('T', 'N', nmol, neldo, nelorbh, zone, mu_c(firstmmu + 2 * nelorbh)&
                                &, 2 * nelorbh, winv(1, 0, nelup1), nelorb5, zzero&
                                &, psip(2 * nmol * (nelup + nelup_mat) + zerop1), nmol)
                        call zgemm_('N', 'N', nmol, nelup_mat, nmol, zone, detmat_c(firstmdet), nelorb_c&
                                &, psip(2 * nmol * nelup_mat + 1), nmol, zzero, psip, nmol)

!                       psipb(1:4 * nmol * nelup_mat) = 0.d0
                        call dscalzero_(4*nmol*nelup_mat,0.d0,psipb,1) 

                        CALL ZGEMM_B('N', 'N', 2 * nelorbh, nelup_mat, nmol, zone, mu_c(firstmmu)&
                                &, 2 * nelorbh, mu_cb(firstmmu), 2 * nelorbh, psip, nmol, psipb, nmol, zzero&
                                &, winvbarb, 2 * nelorbh)

                        CALL ZGEMM_B('N', 'N', nmol, nelup_mat, nmol, zone, detmat_c(firstmdet)&
                                &, nelorb_c, detmat_cb(firstmdet), nelorb_c, psip(2 * nmol * nelup_mat + 1)&
                                &, nmol, psipb(2 * nmol * nelup_mat + 1), nmol, zzero, psipb, nmol)

                        CALL ZGEMM_B('T', 'N', nmol, neldo, nelorbh, zone, mu_c(firstmmu + 2 * nelorbh)&
                                &, 2 * nelorbh, mu_cb(firstmmu + 2 * nelorbh), 2 * nelorbh, winv(1, 0, nelup1), nelorb5&
                                &, winvb(1, 0, nelup1), nelorbh, zzero, psipb(2 * nmol * (nelup_mat + nelup) + zerop1), nmol)

                        CALL ZGEMM_B('T', 'N', nmol, nelup, nelorbh, zone, mu_c(firstmmu), 2 * nelorbh&
                                &, mu_cb(firstmmu), 2 * nelorbh, winv, nelorb5, winvb &
                                &, nelorbh, zzero, psipb(2 * nmol * nelup_mat + 1), nmol)

                    else

                        call zgemm_('T', 'N', nmol, neldo, nelorbh, zone, mu_c(firstmmu), nelorbh&
                                &, winv(1, 0, nelup1), nelorb5, zzero, psip(2 * nmol * neldo + zerop1), nmol)
                        call zgemm_('N', 'N', nmol, neldo, nmol, zone, detmat_c(firstmdet), nelorb_c&
                                &, psip(2 * nmol * neldo + 1), nmol, zzero, psip, nmol)

!                       psipb(1:4 * nmol * neldo) = 0.d0
                        call dscalzero_(4*nmol*neldo,0.d0,psipb,1)


                        !  Here we assume the direct algorithm in the case yerprojm=.false.
                        !  so winvbar is m_c detmat_c mu_c^T

                        CALL ZGEMM_B('N', 'N', nelorbh, neldo, nmol, zone, mu_c(firstmmu), nelorbh, mu_cb(firstmmu)&
                                &, nelorbh, psip, nmol, psipb, nmol, zzero, winvbarb(1, nelup1), nelorbh)

                        CALL ZGEMM_B('N', 'N', nmol, neldo, nmol, zone, detmat_c(firstmdet), nelorb_c&
                                &, detmat_cb(firstmdet), nelorb_c, psip(2 * nmol * neldo + 1), nmol, psipb(2 * nmol * neldo + 1), nmol&
                                &, zzero, psipb, nmol)

                        CALL ZGEMM_B('T', 'N', nmol, neldo, nelorbh, zone, mu_c(firstmmu), nelorbh&
                                &, mu_cb(firstmmu), nelorbh, winv(1, 0, nelup1), nelorb5, winvb(1, &
                                        0, nelup1), nelorbh, zzero, psipb(2 * nmol * neldo + 1), nmol)

                    end if

                else
                    if (ipf.eq.2) then
                        call dgemm_('T', 'N', nmol, nelup, nelorbh, 1.d0, mu_c(firstmmu), 2 * nelorbh&
                                &, winv, nelorb5, 0.d0, psip(nmol * nelup_mat + 1), nmol)
                        call dgemm_('T', 'N', nmol, neldo, nelorbh, 1.d0, mu_c(firstmmu + nelorbh), 2 * nelorbh&
                                &, winv(1, 0, nelup + 1), nelorb5, 0.d0, psip(nmol * (nelup + nelup_mat) + 1), nmol)
                        call dgemm_('N', 'N', nmol, nelup_mat, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, psip(nmol * nelup_mat + 1), nmol, 0.d0, psip, nmol)

!                       psipb(1:2 * nmol * nelup_mat) = 0.d0
                        call dscalzero_(2*nmol*nelup_mat,0.d0,psipb,1)


                        CALL DGEMM_B('N', 'N', 2 * nelorbh, nelup_mat, nmol, 1.d0, mu_c(firstmmu), 2 * nelorbh, &
                                & mu_cb(firstmmu), 2 * nelorbh, psip, nmol, psipb, nmol, 0.d0, winvbarb, 2 * nelorbh)

                        CALL DGEMM_B('N', 'N', nmol, nelup_mat, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, detmat_cb(firstmdet), nelorb_c, psip(nmol * nelup_mat + 1)&
                                &, nmol, psipb(nmol * nelup_mat + 1), nmol, 0.d0, psipb, nmol)

                        CALL DGEMM_B('T', 'N', nmol, neldo, nelorbh, 1.d0, mu_c(firstmmu + nelorbh)&
                                &, 2 * nelorbh, mu_cb(firstmmu + nelorbh), 2 * nelorbh, winv(1, 0, nelup1), nelorb5&
                                &, winvb(1, 0, nelup1), nelorbh, 0.d0, psipb(nmol * (nelup_mat + nelup) + zerop1), nmol)

                        CALL DGEMM_B('T', 'N', nmol, nelup, nelorbh, 1.d0, mu_c(firstmmu), 2 * nelorbh&
                                &, mu_cb(firstmmu), 2 * nelorbh, winv, nelorb5, winvb&
                                &, nelorbh, 0.d0, psipb(nmol * nelup_mat + 1), nmol)

                    else
                        !OPT   save matrices psip  2xnmolxneldo real number
                        call dgemm_('T', 'N', nmol, neldo, nelorbh, 1.d0, mu_c(firstmmu), nelorbh&
                                &, winv(1, 0, nelup1), nelorb5, 0.d0, psip(nmol * neldo + 1), nmol)
                        call dgemm_('N', 'N', nmol, neldo, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, psip(nmol * neldo + 1), nmol, 0.d0, psip, nmol)

!                       psipb(1:2 * nmol * neldo) = 0.d0
                        call dscalzero_(2*nmol*neldo,0.d0,psipb,1)

                        !  Here we assume the direct algorithm in the case yerprojm=.false.
                        !  so winvbar is m_c detmat_c mu_c^T

                        CALL DGEMM_B('N', 'N', nelorbh, neldo, nmol, 1.d0, mu_c(firstmmu), nelorbh, mu_cb(firstmmu)&
                                &, nelorbh, psip, nmol, psipb, nmol, 0.d0, winvbarb(1, nelup1), nelorbh)

                        CALL DGEMM_B('N', 'N', nmol, neldo, nmol, 1.d0, detmat_c(firstmdet), nelorb_c&
                                &, detmat_cb(firstmdet), nelorb_c, psip(nmol * neldo + 1), nmol, psipb(nmol * neldo + 1), nmol, 0.d0&
                                &, psipb, nmol)

                        CALL DGEMM_B('T', 'N', nmol, neldo, nelorbh, 1.d0, mu_c(firstmmu), nelorbh&
                                &, mu_cb(firstmmu), nelorbh, winv(1, 0, nelup1), nelorb5, winvb(1, &
                                        &             0, nelup1), nelorbh, 0.d0, psipb(nmol * neldo + 1), nmol)
                    end if
                endif
            END IF
        endif
    END SUBROUTINE TASK5_B

    !  Differentiation of task8 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: psip winvbar ainv
    !                winv
    !   of linear combination of output variables: psip winvbar psidetlnt
    !                ainv
    SUBROUTINE TASK8_B(winv, winvb, winvbar, winvbarb, psidetlnt, &
            &    psidetlntb, ainv, ainvb)
        implicit none
        REAL*8 :: winv(ipc * nelorb, 0:indt4, nel), winvbar(ipc * ipf * nelorbh, nel_mat)
        REAL*8 :: winvb(ipc * nelorb, 0:0, nel), winvbarb(ipc * ipf * nelorbh, nel_mat)
        REAL*8 :: psidetlnt, ainv(ipc * nelup_mat, nelup_mat)
        REAL*8 :: psidetlntb(*), ainvb(ipc * nelup_mat, nelup_mat)
        real*8, allocatable :: ainv_sav(:, :)
        complex*16 costpsic
        real*8 costpsi
        integer k
        complex*16 psicomp
        !   reverse algorithm of:
        !  A and B rectangular matrices with same dimensions, sam raws and columns
        !  nelorbh, nelup
        !   y=psidetlnt
        !   A=winv(1:nelorbh,0,1:nelup)
        !   B=winvbar(1:nelorbh,nelup+1:2*nelup)
        !   winvbar=detmat*winv costrained
        !  Here   ainv = (A^T B)^-1 given in input
        !    Output y and C (square matrix = ainv)
        !    y=ReTr ln (A^T B)
        !    C=(A^T B)^-1

        !   ainv (C) known in input assumed (no recompute the inverse)


        !    first dependence on y
        if(ieslog) then
            !  NB the pfaffian is the square root of the det that's why the factor 1/2
            if(ipf.eq.2) psidetlntb(1:ipc) = psidetlntb(1:ipc) / 2.d0
            if(ipc.eq.2) then
                costpsic = dcmplx(psidetlntb(1), psidetlntb(2))

                !    psicomp=dcmplx(psidetlntb)
                if(ipf.eq.2) then
                    !  ainv is the reverse vector obtained after applying
                    ! the back propagation to y=1/2 tr[ log A]  --> ainv^T
                    if(ndiff.ne.0) then
                        allocate(ainv_sav(2 * nelup_mat, nelup_mat))
#ifdef  _OFFLOAD
!$omp target  update from (ainv)
#endif
                        ainv_sav = ainv

                        if(npar_eagp.gt.0) call update_eagp_complex(.true., costpsic, ndiff, nelup_mat, ainv, eagp_pfaffb)

#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                        do k = 1, ndiff
                            do i = 1, nelup_mat - ndiff
                                ainv(2 * nelup_mat - 2 * k + 1, i) = ainv(2 * nelup_mat - 2 * k + 1, i) - ainv(2 * i - 1, nelup_mat - k + 1)
                                ainv(2 * nelup_mat - 2 * k + 2, i) = ainv(2 * nelup_mat - 2 * k + 2, i) - ainv(2 * i, nelup_mat - k + 1)
                            enddo
                        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                    endif

                    call conjmat_(nelorbh, nel, winv, nelorb5)
                    call zgemm_('N', 'C', nelorbh, nelup_mat, nelup, costpsic, winv, nelorb5&
                            &, ainv, nelup_mat, zone, winvbarb, 2 * nelorbh)
                    call zgemm_('N', 'C', nelorbh, nelup_mat, neldo, costpsic, winv(1, 0, nelup1)&
                            &, nelorb5, ainv(1, nelup1), nelup_mat, zone, winvbarb(2 * nelorbh + 1, 1), 2 * nelorbh)
                    !   restore winv
                    call conjmat_(nelorbh, nel, winv, nelorb5)
                    call conjmat_(nelup_mat, nelup_mat, ainv, nelup_mat)
                    call conjmat_(2 * nelorbh, nelup_mat, winvbar, 2 * nelorbh)
                    call zgemm_('N', 'N', nelorbh, nelup, nelup_mat, costpsic, winvbar&
                            &, 2 * nelorbh, ainv, nelup_mat, zone, winvb, nelorbh)
                    call zgemm_('N', 'N', nelorbh, neldo, nelup_mat, costpsic&
                            &, winvbar(2 * nelorbh + 1, 1), 2 * nelorbh, ainv(1, nelup1), nelup_mat, zone&
                            &, winvb(1, 0, nelup1), nelorbh)
                    !   restore ainv, winvbar
                    call conjmat_(nelup_mat, nelup_mat, ainv, nelup_mat)
                    call conjmat_(2 * nelorbh, nelup_mat, winvbar, 2 * nelorbh)
                    if(ndiff.ne.0) then
                        ainv = ainv_sav
#ifdef _OFFLOAD
!$omp target update to (ainv)
#endif
                        deallocate(ainv_sav)
                    endif

                else
                    call conjmat_(nelorbh, nelup, winv, nelorb5)
                    call zgemm_('N', 'C', nelorbh, nelup, nelup, costpsic, winv, nelorb5&
                            &, ainv, nelup, zone, winvbarb(1, nelup + 1), nelorbh)
                    !   restore winv
                    call conjmat_(nelorbh, nelup, winv, nelorb5)
                    call conjmat_(nelup, nelup, ainv, nelup)
                    call conjmat_(nelorbh, nelup, winvbar(1, nelup + 1), nelorbh)
                    call zgemm_('N', 'N', nelorbh, nelup, nelup, costpsic, winvbar(1, nelup + 1)&
                            &, nelorbh, ainv, nelup, zone, winvb, nelorbh)
                    !   restore ainv, winvbar
                    call conjmat_(nelup, nelup, ainv, nelup)
                    call conjmat_(nelorbh, nelup, winvbar(1, nelup + 1), nelorbh)
                endif

            else

                costpsi = psidetlntb(1)
                if(ipf.eq.2) then
                    if(ndiff.ne.0) then
                        allocate(ainv_sav(nelup_mat, nelup_mat))
#ifdef  _OFFLOAD
!$omp target  update from (ainv)
#endif
                        ainv_sav = ainv
                        if(npar_eagp.gt.0) then
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                            do k = 1, ndiff
                                do j = 1, ndiff
                                    !         psip(nelup_mat-ndiff+k,nelup_mat-ndiff+j)=eagp_pfaff(k,j)
                                    eagp_pfaffb(k, j) = eagp_pfaffb(k, j) + costpsi * ainv(nelup_mat - ndiff + j, nelup_mat - ndiff + k)
                                    ainv(nelup_mat - ndiff + j, nelup_mat - ndiff + k) = 0.d0
                                enddo
                            enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                        endif
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                        do k = 1, ndiff
                            do i = 1, nelup_mat - ndiff
                                ainv(nelup_mat - k + 1, i) = ainv(nelup_mat - k + 1, i) - ainv(i, nelup_mat - k + 1)
                            enddo
                        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                        !        do k=1,ndiff
                        !         do j=1,ndiff
                        !         psip(nelup_mat-ndiff+k,nelup_mat-ndiff+j)=eagp_pfaff(k,j)
                        !         enddo
                        !        enddo

                    endif
                    call dgemm_('N', 'T', nelorbh, nelup_mat, nelup, costpsi, winv, nelorb5&
                            &, ainv, nelup_mat, 1.d0, winvbarb, 2 * nelorbh)
                    call dgemm_('N', 'T', nelorbh, nelup_mat, neldo, costpsi, winv(1, 0, nelup1)&
                            &, nelorb5, ainv(1, nelup1), nelup_mat, 1.d0, winvbarb(nelorbh + 1, 1), 2 * nelorbh)

                    call dgemm_('N', 'N', nelorbh, nelup, nelup_mat, costpsi, winvbar&
                            &, 2 * nelorbh, ainv, nelup_mat, 1.d0, winvb, nelorbh)
                    call dgemm_('N', 'N', nelorbh, neldo, nelup_mat, costpsi&
                            &, winvbar(nelorbh + 1, 1), 2 * nelorbh, ainv(1, nelup1), nelup_mat, 1.d0&
                            &, winvb(1, 0, nelup1), nelorbh)

                    if(ndiff.ne.0) then
                        !    Restore ainv
                        ainv = ainv_sav
#ifdef _OFFLOAD
!$omp target update to (ainv)
#endif
                        deallocate(ainv_sav)
                    endif
                    !    recomputing the unpaired orbital put in psip

                else

                    call dgemm_('N', 'T', nelorbh, nelup, nelup, costpsi, winv, nelorb5&
                            &, ainv, nelup, 1.d0, winvbarb(1, nelup + 1), nelorbh)

                    call dgemm_('N', 'N', nelorbh, nelup, nelup, costpsi, winvbar(1, nelup + 1)&
                            &, nelorbh, ainv, nelup, 1.d0, winvb, nelorbh)

                endif

            endif
        endif

        !   second dpendence on C only for the local energy
        if(ieseloc) then

            if(ipc.eq.2) then

                !   computing bar C^T ainv storing in psip

                if(ipf.eq.2) then

                    call zgemm_('N', 'C', nelup_mat, nelup_mat, nelup_mat, zone, ainvb, nelup_mat&
                            &, ainv, nelup_mat, zzero, psip, nelup_mat)

                    !   computing  ainv bar C^T ainv storing in ainvb
                    call zgemm_('C', 'N', nelup_mat, nelup_mat, nelup_mat, zone, ainv, nelup_mat&
                            &, psip, nelup_mat, zzero, ainvb, nelup_mat)

                    !   ainvb is now ab,  since ab is not used any longer
                    if(ndiff.ne.0) then

                        if(npar_eagp.gt.0) call update_eagp_complex(.true., zone, ndiff, nelup_mat, ainvb, eagp_pfaffb)

#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                        do k = 1, ndiff
                            do i = 1, nelup_mat - ndiff
                                ainvb(2 * i - 1, nelup_mat - k + 1) = ainvb(2 * i - 1, nelup_mat - k + 1) - ainvb(2 * nelup_mat - 2 * k + 1, i)
                                ainvb(2 * i, nelup_mat - k + 1) = ainvb(2 * i, nelup_mat - k + 1) - ainvb(2 * nelup_mat - 2 * k + 2, i)
                            enddo
                        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                    endif

                    call  zgemm_b('T', 'N', nelup, nelup_mat, nelorbh, zmone, winv, nelorb5, winvb&
                            &, nelorbh, winvbar, 2 * nelorbh, winvbarb, 2 * nelorbh, zzero, ainvb, nelup_mat)
                    call  zgemm_b('T', 'N', neldo, nelup_mat, nelorbh, zmone, winv(1, 0, nelup1)&
                            &, nelorb5, winvb(1, 0, nelup1), nelorbh, winvbar(2 * nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(2 * nelorbh + 1, 1), 2 * nelorbh, zzero, ainvb(2 * nelup + zerop1, 1), nelup_mat)

                else

                    call zgemm_('N', 'C', nelup, nelup, nelup, zone, ainvb, nelup, ainv, nelup&
                            &, zzero, psip, nelup)


                    !   computing  ainv bar C^T ainv storing in ainvb
                    call zgemm_('C', 'N', nelup, nelup, nelup, zone, ainv, nelup, psip, nelup&
                            &, zzero, ainvb, nelup)

                    !   ainvb is now ab,  since ab is not used any longer

                    call  zgemm_b('T', 'N', nelup, nelup, nelorbh, zmone, winv, nelorb5, winvb, nelorbh&
                            &, winvbar(1, nelup + 1), nelorbh, winvbarb(1, nelup + 1), nelorbh, zzero, ainvb, nelup)

                endif

            else

                if(ipf.eq.2) then
                    call dgemm_('N', 'T', nelup_mat, nelup_mat, nelup_mat, 1.d0, ainvb, nelup_mat&
                            &, ainv, nelup_mat, 0.d0, psip, nelup_mat)
                    call dgemm_('T', 'N', nelup_mat, nelup_mat, nelup_mat, 1.d0, ainv, nelup_mat, psip&
                            &, nelup_mat, 0.d0, ainvb, nelup_mat)
                    if(ndiff.ne.0) then
                        if(npar_eagp.gt.0) then
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                            do k = 1, ndiff
                                do j = 1, ndiff
                                    !         psip(nelup_mat-ndiff+k,nelup_mat-ndiff+j)=eagp_pfaff(k,j)
                                    eagp_pfaffb(j, k) = eagp_pfaffb(j, k) + ainvb(nelup_mat - ndiff + k, nelup_mat - ndiff + j)
                                    ainvb(nelup_mat - ndiff + k, nelup_mat - ndiff + j) = 0.d0
                                enddo
                            enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                        endif
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
                        do k = 1, ndiff
                            do i = 1, nelup_mat - ndiff
                                ainvb(i, nelup_mat - k + 1) = ainvb(i, nelup_mat - k + 1) - ainvb(nelup_mat - k + 1, i)
                            enddo
                        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
                        !     ainvb(nelup_mat,1:nelup_mat-1)=ainvb(nelup_mat,1:nelup_mat-1)-ainvb(1:nelup_mat-1,nelup_mat)
                    endif
                    call  dgemm_b('T', 'N', nelup, nelup_mat, nelorbh, -1.d0, winv, nelorb5, winvb&
                            &, nelorbh, winvbar, 2 * nelorbh, winvbarb, 2 * nelorbh, 0.d0, ainvb, nelup_mat)
                    call  dgemm_b('T', 'N', neldo, nelup_mat, nelorbh, -1.d0, winv(1, 0, nelup + 1)&
                            &, nelorb5, winvb(1, 0, nelup + 1), nelorbh, winvbar(nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(nelorbh + 1, 1), 2 * nelorbh, 0.d0, ainvb(nelup + 1, 1), nelup_mat)

                else
                    call dgemm_('N', 'T', nelup, nelup, nelup, 1.d0, ainvb, nelup, ainv, nelup&
                            &, 0.d0, psip, nelup)
                    call dgemm_('T', 'N', nelup, nelup, nelup, 1.d0, ainv, nelup, psip, nelup&
                            &, 0.d0, ainvb, nelup)
                    call  dgemm_b('T', 'N', nelup, nelup, nelorbh, -1.d0, winv, nelorb5, winvb, nelorbh&
                            &, winvbar(1, nelup + 1), nelorbh, winvbarb(1, nelup + 1), nelorbh, 0.d0, ainvb, nelup)
                endif

            endif

        endif

        psidetlntb(1:ipc) = 0.d0

        !    ainvb=0.d0 is already done by dgemm_b zgemm_b

    END SUBROUTINE TASK8_B


    !  Differentiation of task10 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: dd cnorm r rion
    !                rmusin rmucos rmu zeta psip winvup winvbar ainv
    !                kel winvdo
    !   of linear combination of output variables: winvup winvdo

    SUBROUTINE TASK10_B(ainv, ainvb, winvbar, winvbarb, kel, kelb, rion, rionb, &
            & ainvup, ainvupb, ainvdo, ainvdob, winvup, winvupb, winvdo, winvdob, cellscaleb, s2rb&
            &, psip, psipb)
        !   USE DIFFSIZES
        !  Hint: ISIZE1OFcnorm should be the size of dimension 1 of array cnorm
        !  Hint: ISIZE1OFpsip should be the size of dimension 1 of array psip
        !  Hint: ISIZE1OFdd should be the size of dimension 1 of array dd
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: ainv(ipc * nelup_mat, nelup_mat), winvbar(ipc * ipf * nelorbh, nel_mat)&
                &, kel(3, nel, 0:indt), rion(3, nion)
        REAL*8 :: ainvb(ipc * nelup_mat, nelup_mat), winvbarb(ipc * ipf * nelorbh, nel_mat), kelb(3, &
                &    nel, 0:indt)
        REAL*8 :: winvup(ipc * nelup, indt + 4), winvdo(max(ipc * neldo, 1), *), ainvup(&
                &    ipc * nelup, nelorbh), ainvdo(max(ipc * neldo, 1), nelorbh), rionb(3, nion)
        REAL*8 :: winvupb(ipc * nelup, indt + 4), winvdob(max(ipc * neldo, 1), *), ainvupb&
                &    (ipc * nelup, nelorbh), ainvdob(max(ipc * neldo, 1), *)
        REAL*8 cellscaleb(3), s2rb(3, 3), psip(ipc * nelorbh,0: *), psipb(ipc * nelorbh,0: *)
        integer indr, indi, k, kr, ki
        if(ncore.le.0.and.neldo.gt.0.and..not.lrdmc_deru) then
            yesupel = .false.
            DO j = 1, neldo
                !     recomputing psip
                if(indt4.eq.0) then
                    call upnewwf(indt, 0, 0, 0, nshellh, ioptorb, ioccup&
                            &, kel(1, j + nelup, 0), nel, r, rmu, dd, zeta, rion, psip(1, indt + ip5), psip, nelorbh&
                            &, nion, kion, iflagnorm, cnorm, LBox, rmucos, rmusin, 1d-9&
                            &, indpar_tab, indorb_tab, indshell_tab, .false.)
                else
                    psip(:, indt + 1:indt + 4) = winv(:, indt + 1:indt + 4, j + nelup)
                endif

                do i = 1, indt
                    psipb(1:ipc * nelorbh, i) = 0.d0
                enddo
                if(ipc.eq.2) then

        call zgemv_b('T',nelorbh,4,zone,psip(1,indt+1),nelorbh,psipb(1,indt+1),nelorbh,ainvdo(2*j-1,1),neldo,ainvdob(2*j-1,1),neldo,zone,winvdob(2*j-1,indt+1),neldo)
                else
        
        call dgemv_b('T',nelorbh,4,1.d0,psip(1,indt+1),nelorbh,psipb(1,indt+1),nelorbh,ainvdo(j,1),neldo,ainvdob(j,1),neldo,1.d0,winvdob(j,indt+1),neldo)

                endif

                if(yesforce.or.yeszagp) then
                    if(.not.donebig) then
                    CALL UPNEWWF_B(indt, 0, 0, 0, nshellh, ioptorb, &
                            &                 ioccup, kel(1, j + nelup, 0), kelb(1, j + nelup, 0), nel, r&
                            &, rb, rmu, rmub, dd, ddb, zeta, rion, rionb, &
                            &                 psip(1, indt + ip5), psipb(1, indt + ip5), psip, psipb, &
                            &                 nelorbh, nion, kion, iflagnorm, cnorm, lbox, &
                            &         rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                            &           indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)
                    else
   winvb_big(:,indt+1:indt+4,j+nelup)=winvb_big(:,indt+1:indt+4,j+nelup)+psipb(:,indt+1:indt+4)
                    psipb(:,indt+1:indt+4)=0.d0
                    endif
                endif
            END DO
#ifdef _OFFLOAD
!$omp target update to (ainvdob(:,1:nelorbh))
#endif
            if(ipc.eq.2) then
                if(ipf.eq.2) then
                    CALL ZGEMM_B('T', 'T', neldo, nelorbh, nelup_mat, zone, ainv(1, nelup1)&
                            &, nelup_mat, ainvb(1, nelup1), nelup_mat, winvbar(2 * nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(2 * nelorbh + 1, 1), 2 * nelorbh, zzero, ainvdob, neldo)
                else
                    CALL ZGEMM_B('N', 'T', neldo, nelorbh, nelup, zone, ainv, nelup, ainvb, &
                            &     nelup, winvbar, nelorbh, winvbarb, nelorbh, zzero, ainvdob, neldo)
                endif
            else
                if(ipf.eq.2) then
                    CALL DGEMM_B('T', 'T', neldo, nelorbh, nelup_mat, 1.d0, ainv(1, nelup1)&
                            &, nelup_mat, ainvb(1, nelup1), nelup_mat, winvbar(nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(nelorbh + 1, 1), 2 * nelorbh, 0.d0, ainvdob, neldo)
                else
                    CALL DGEMM_B('N', 'T', neldo, nelorbh, nelup, 1.d0, ainv, nelup, ainvb, &
                            & nelup, winvbar, nelorbh, winvbarb, nelorbh, 0.d0, ainvdob, neldo)
                endif
            endif

        ELSE IF (neldo .GT. 0) THEN
            ! you are not doing standard VMC or SR
            !        call dscalzero(nelorbh*neldo,0.d0,ainvdo,1)
            yesupel = .false.
            DO j = 1, neldo
                !       recompute psip
                if(indt4.eq.0) then
                    CALL upnewwf(indt, 0, indtm(j + nelup), 0, nshellh, ioptorb, &
                            & ioccup, kel(1, j + nelup, 0), nel, r, rmu, dd, zeta, &
                            & rion, psip(1, indt + ip5), psip, nelorbh, nion, kion, &
                            & iflagnorm, cnorm, lbox, rmucos, rmusin, 1d-9, &
                            & indpar_tab, indorb_tab, indshell_tab, .false.)
                else
                    psip(:, indt + 1:indt + 4) = winv(:, indt + 1:indt + 4, j + nelup)
                    psip(:, 1:indtm(j + nelup)) = winv(:, 1:indtm(j + nelup), j + nelup)
                endif

                if(ipc.eq.2) then
         call zgemv_b('T',nelorbh,indt+4,zone,psip(1,1),nelorbh,psipb(1,1),nelorbh,ainvdo(2*j-1,1),neldo,ainvdob(2*j-1,1),neldo,zone,winvdob(2*j-1,1),neldo)

                else
         call dgemv_b('T',nelorbh,indt+4,1.d0,psip(1,1),nelorbh,psipb(1,1),nelorbh,ainvdo(j,1),neldo,ainvdob(j,1),neldo,1.d0,winvdob(j,1),neldo)

                endif

                if(yesforce.or.yeszagp) then
                    if(.not.donebig)  then
                    CALL UPNEWWF_B(indt, 0, indtm(j + nelup), 0, nshellh, ioptorb, &
                            &                 ioccup, kel(1, j + nelup, 0), kelb(1, j + nelup, 0), nel, r&
                            &, rb, rmu, rmub, dd, ddb, zeta, rion, rionb, &
                            &                 psip(1, indt + ip5), psipb(1, indt + ip5), psip, psipb, &
                            &                 nelorbh, nion, kion, iflagnorm, cnorm, lbox, &
                            &rmucos, rmucosb, rmusin, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                            &         indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)
                     else
   winvb_big(:,1:indt+4,j+nelup)=winvb_big(:,1:indt+4,j+nelup)+psipb(:,1:indt+4)
             psipb(:,1:indt+4)=0.d0
                     endif
                 endif
            END DO
#ifdef _OFFLOAD
!$omp target update to (ainvdob(:,1:nelorbh))
#endif
            if(ipc.eq.2) then
                if(ipf.eq.2) then
                    CALL ZGEMM_B('T', 'T', neldo, nelorbh, nelup_mat, zone, ainv(1, nelup + 1)&
                            &, nelup_mat, ainvb(1, nelup + 1), nelup_mat, winvbar(2 * nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(2 * nelorbh + 1, 1), 2 * nelorbh, zzero, ainvdob, neldo)
                else
                    CALL ZGEMM_B('N', 'T', neldo, nelorbh, nelup, zone, ainv, nelup, ainvb, &
                            & nelup, winvbar, nelorbh, winvbarb, nelorbh, zzero, ainvdob, neldo)
                endif
            else
                if(ipf.eq.2) then
                    CALL DGEMM_B('T', 'T', neldo, nelorbh, nelup_mat, 1.d0, ainv(1, nelup + 1)&
                            &, nelup_mat, ainvb(1, nelup + 1), nelup_mat, winvbar(nelorbh + 1, 1), 2 * nelorbh&
                            &, winvbarb(nelorbh + 1, 1), 2 * nelorbh, 0.d0, ainvdob, neldo)
                else
                    CALL DGEMM_B('N', 'T', neldo, nelorbh, nelup, 1.d0, ainv, nelup, ainvb, &
                            &nelup, winvbar, nelorbh, winvbarb, nelorbh, 0.d0, ainvdob, neldo)
                endif
            endif
        END IF



        !   spin up

        IF (ncore.le.0.and..not.lrdmc_deru) THEN
            yesupel = .true.
            DO j = 1, nelup
                !       recompute psip
                if(indt4.eq.0) then
                    call upnewwf(indt, 0, 0, 0, nshellh, ioptorb, ioccup, kel(1, j, 0)   &
                            &, nel, r, rmu, dd, zeta, rion, psip(1, indt + ip5), psip, nelorbh, nion, kion         &
                            &, iflagnorm, cnorm, LBox, rmucos, rmusin, 1d-9&
                            &, indpar_tab, indorb_tab, indshell_tab, .true.)
                else
                    psip(:, indt + 1:indt + 4) = winv(:, indt + 1:indt + 4, j)
                endif
                if(ipc.eq.2) then
        call zgemv_b('T',nelorbh,4,zone,psip(1,indt+1),nelorbh,psipb(1,indt+1),nelorbh,ainvup(2*j-1,1),nelup,ainvupb(2*j-1,1),nelup,zone,winvupb(2*j-1,indt+1),nelup)

                else

         call dgemv_b('T',nelorbh,4,1.d0,psip(1,indt+1),nelorbh,psipb(1,indt+1),nelorbh,ainvup(j,1),nelup,ainvupb(j,1),nelup,1.d0,winvupb(j,indt+1),nelup)

                endif
                if(yesforce.or.yeszagp) then
                    if(.not.donebig) then
                    CALL UPNEWWF_B(indt, 0, 0, 0, nshellh, ioptorb, ioccup, &
                            &                 kel(1, j, 0), kelb(1, j, 0), nel, r, rb, rmu, rmub, dd&
                            &, ddb, zeta, rion, rionb, psip(1, indt + ip5), &
                            &                 psipb(1, indt + ip5), psip, psipb, nelorbh, nion, kion, &
                            &                 iflagnorm, cnorm, lbox, rmucos, rmucosb, rmusin&
                            &, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                            &                 indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)

                     else
 winvb_big(:,indt+1:indt+4,j)=winvb_big(:,indt+1:indt+4,j)+psipb(:,indt+1:indt+4)
             psipb(:,indt+1:indt+4)=0.d0
                     endif
                endif
            END DO
        ELSE
            yesupel = .true.
            DO j = 1, nelup
                !      recompute psip
                if(indt4.eq.0) then
                    call upnewwf(indt, 0, indtm(j), 0, nshellh, ioptorb, ioccup, kel(1, j, 0)   &
                            &, nel, r, rmu, dd, zeta, rion, psip(1, indt + ip5), psip, nelorbh, nion, kion      &
                            &, iflagnorm, cnorm, LBox, rmucos, rmusin, 1d-9&
                            &, indpar_tab, indorb_tab, indshell_tab, .true.)
                else
                    psip(:, 1:indtm(j)) = winv(:, 1:indtm(j), j)
                    psip(:, indt + 1:indt + 4) = winv(:, indt + 1:indt + 4, j)
                endif
                if(ipc.eq.2) then
        call zgemv_b('T',nelorbh,indt+4,zone,psip(1,1),nelorbh,psipb(1,1),nelorbh,ainvup(2*j-1,1),nelup,ainvupb(2*j-1,1),nelup,zone,winvupb(2*j-1,1),nelup)
                else
         call dgemv_b('T',nelorbh,indt+4,1.d0,psip(1,1),nelorbh,psipb(1,1),nelorbh,ainvup(j,1),nelup,ainvupb(j,1),nelup,1.d0,winvupb(j,1),nelup)
                endif
                if(yesforce.or.yeszagp) then
                    if(.not.donebig) then
                    CALL UPNEWWF_B(indt, 0, indtm(j), 0, nshellh, ioptorb, ioccup, &
                            &                 kel(1, j, 0), kelb(1, j, 0), nel, r, rb, rmu, rmub, dd&
                            &, ddb, zeta, rion, rionb, psip(1, indt + ip5), &
                            &                 psipb(1, indt + ip5), psip, psipb, nelorbh, nion, kion, &
                            &                 iflagnorm, cnorm, lbox, rmucos, rmucosb, rmusin&
                            &, rmusinb, 1d-9, cellscale, cellscaleb, s2r, s2rb, &
                            &                 indpar_tab, indorb_tab, indshell_tab, adr_nion, ind_nion)
                    else
   winvb_big(:,1:indt+4,j)=winvb_big(:,1:indt+4,j)+psipb(:,1:indt+4)
             psipb(:,1:indt+4)=0.d0
                    endif
                endif
            END DO
        END IF
#ifdef _OFFLOAD
!$omp target update to (ainvupb)
#endif
        if(ipc.eq.2) then
            if(ipf.eq.2) then
                CALL ZGEMM_B('T', 'T', nelup, nelorbh, nelup_mat, zone, ainv, nelup_mat, ainvb, &
                        &nelup_mat, winvbar, 2 * nelorbh, winvbarb, 2 * nelorbh, zzero, ainvupb, nelup)
            else
                CALL ZGEMM_B('T', 'T', nelup, nelorbh, nelup, zone, ainv, nelup, ainvb, &
                        &           nelup, winvbar(1, nelup + 1), nelorbh, winvbarb(1, nelup + 1), nelorbh, &
                        &           zzero, ainvupb, nelup)
            endif
        else
            if(ipf.eq.2) then
                CALL DGEMM_B('T', 'T', nelup, nelorbh, nelup_mat, 1.d0, ainv, nelup_mat, ainvb, &
                        &nelup_mat, winvbar, 2 * nelorbh, winvbarb, 2 * nelorbh, 0.d0, ainvupb, nelup)
            else
                CALL DGEMM_B('T', 'T', nelup, nelorbh, nelup, 1.d0, ainv, nelup, ainvb, &
                        &nelup, winvbar(1, nelup + 1), nelorbh, winvbarb(1, nelup + 1), nelorbh, &
                        &0.d0, ainvupb, nelup)
            endif
        endif

    END SUBROUTINE TASK10_B
    !  Differentiation of task11 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: vpot tmu winvup
    !                tabpip winvdo
    !   of linear combination of output variables: eloc
    SUBROUTINE TASK11_B(winvup, winvupb, winvdo, winvdob, tabpip, tabpipb&
            &, tmu, tmub, vpot, vpotb, eloc, elocb)
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: winvup(ipc * nelup, indt + 4), winvdo(max(ipc * neldo, 1), *), &
                &    tabpip(nel, indt + 4)
        REAL*8 :: winvupb(ipc * nelup, indt + 4), winvdob(max(ipc * neldo, 1), *), tabpipb(&
                &    nel, indt + 4)
        REAL*8 tmu(nelup + neldo, indt), tmub(nelup + neldo, indt), vpot, vpotb
        REAL*8 :: eloc
        REAL*8 :: elocb(*)
        REAL*8 :: tempb0
        REAL*8 :: tempb1
        REAL*8 :: tempb
        integer indel
        !     compute local energy given winvup winvdo tabpip
        !     input winvup,winvdo tabpip tmu vpot
        !     output Local energy eloc
        !     contribution due to the non local pseudo



        tmub(:, :) = 0.0_8
        winvupb(:, :) = 0.0_8
        tabpipb(:, :) = 0.0_8
        if(neldo.gt.0) winvdob(:, 1:indt + 4) = 0.0_8

        if(lrdmc_deru) then
            if(ipc.eq.1) then
                DO jj = 1, istart - 1
                    DO i = 1, neldo
                        tmub(i + nelup, jj) = tmub(i + nelup, jj) - elocb(1)
                        tempb0 = -(tabpip(i + nelup, jj) * elocb(1))
                        if(-tmu(i + nelup, jj) * winvdo(i, jj).gt.0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + gamma * winvdo(i, jj) * tempb0
                            winvdob(i, jj) = winvdob(i, jj) + gamma * tmu(i + nelup, jj) * tempb0
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj) - gamma * tmu(i + nelup, jj)&
                                    & * winvdo(i, jj) * elocb(1)
                        else
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) - winvdo(i, jj) * tempb0
                            winvdob(i, jj) = winvdob(i, jj) - tmu(i + nelup, jj) * tempb0
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj) + tmu(i + nelup, jj)&
                                    & * winvdo(i, jj) * elocb(1)
                        endif
                    END DO
                    DO i = 1, nelup
                        tmub(i, jj) = tmub(i, jj) - elocb(1)
                        tempb = -(winvup(i, jj) * elocb(1))
                        if(-tmu(i, jj) * winvup(i, jj).gt.0.d0) then
                            tmub(i, jj) = tmub(i, jj) + gamma * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + gamma * tmu(i, jj) * tempb
                            winvupb(i, jj) = winvupb(i, jj) - gamma * tmu(i, jj) * tabpip(i, jj) * &
                                    &            elocb(1)
                        else
                            tmub(i, jj) = tmub(i, jj) - tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) - tmu(i, jj) * tempb
                            winvupb(i, jj) = winvupb(i, jj) + tmu(i, jj) * tabpip(i, jj) * &
                                    &            elocb(1)
                        endif
                    END DO
                END DO
                DO jj = istart, indt
                    DO i = 1, neldo
                        tempb0 = -(tabpip(i + nelup, jj) * elocb(1))
                        if(-tmu(i + nelup, jj) * winvdo(i, jj).gt.0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + (1.d0 + gamma) * winvdo(i, jj) * tempb0
                            winvdob(i, jj) = winvdob(i, jj) + (1.d0 + gamma) * tmu(i + nelup, jj) * tempb0
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj) - (1.d0 + gamma) * tmu(i + nelup, jj)&
                                    & * winvdo(i, jj) * elocb(1)
                        elseif(npow.gt.0.d0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + npow*(1.d0 + gamma) * winvdo(i, jj) * tempb0
                            winvdob(i, jj) = winvdob(i, jj) + npow*(1.d0 + gamma) * tmu(i + nelup, jj) * tempb0
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj) - npow*(1.d0 + gamma) * tmu(i + nelup, jj)&
                                    & * winvdo(i, jj) * elocb(1)

                        endif
                    END DO
                    DO i = 1, nelup
                        tempb = -(winvup(i, jj) * elocb(1))
                        if(-tmu(i, jj) * winvup(i, jj).gt.0.d0) then
                            tmub(i, jj) = tmub(i, jj) + (1.d0 + gamma) * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + (1.d0 + gamma) * tmu(i, jj) * tempb
                            winvupb(i, jj) = winvupb(i, jj) - (1.d0 + gamma) * tmu(i, jj) * tabpip(i, jj) * &
                                    &            elocb(1)
                        elseif(npow.gt.0.d0) then
                            tmub(i, jj) = tmub(i, jj) + npow*(1.d0 + gamma) * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + npow*(1.d0 + gamma) * tmu(i, jj) * tempb
                            winvupb(i, jj) = winvupb(i, jj) - npow*(1.d0 + gamma) * tmu(i, jj) * tabpip(i, jj) * &
                                    &            elocb(1)
                        endif
                    END DO
                END DO
            else
                DO jj = 1, istart - 1
                    DO i = 1, neldo
                        indel = 2 * i - 1
                        tmub(i + nelup, jj) = tmub(i + nelup, jj) - elocb(1)
                        tempb0 = -tabpip(i + nelup, jj) * elocb(1)
                        tempb1 = -tabpip(i + nelup, jj) * elocb(2)
                        if(-tmu(i + nelup, jj) * winvdo(indel, jj).gt.0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + gamma * winvdo(indel, jj) * tempb0
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + gamma * winvdo(indel + 1, jj) * tempb1
                            winvdob(indel, jj) = winvdob(indel, jj) + gamma * tmu(i + nelup, jj) * tempb0
                            winvdob(indel + 1, jj) = winvdob(indel + 1, jj) + gamma * tmu(i + nelup, jj) * tempb1
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj)&
                                    & - gamma * tmu(i + nelup, jj) * winvdo(indel, jj) * elocb(1)&
                                    & - gamma * tmu(i + nelup, jj) * winvdo(indel + 1, jj) * elocb(2)
                        else
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) - winvdo(indel, jj) * tempb0
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) - winvdo(indel + 1, jj) * tempb1
                            winvdob(indel, jj) = winvdob(indel, jj) - tmu(i + nelup, jj) * tempb0
                            winvdob(indel + 1, jj) = winvdob(indel + 1, jj) - tmu(i + nelup, jj) * tempb1
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj)&
                                    & + tmu(i + nelup, jj) * winvdo(indel, jj) * elocb(1)&
                                    & + tmu(i + nelup, jj) * winvdo(indel + 1, jj) * elocb(2)
                        endif
                    END DO
                    DO i = 1, nelup
                        indel = ipc * (i - 1) + 1
                        tmub(i, jj) = tmub(i, jj) - elocb(1)
                        tempb = -winvup(indel, jj) * elocb(1) - winvup(indel + 1, jj) * elocb(2)
                        tempb1 = tmu(i, jj) * tabpip(i, jj)
                        if(-tmu(i, jj) * winvup(indel, jj).gt.0) then
                            tmub(i, jj) = tmub(i, jj) + gamma * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + gamma * tmu(i, jj) * tempb
                            winvupb(indel, jj) = winvupb(indel, jj) - gamma * tempb1 * elocb(1)
                            winvupb(indel + 1, jj) = winvupb(indel + 1, jj) - gamma * tempb1 * elocb(2)
                        else
                            tmub(i, jj) = tmub(i, jj) - tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) - tmu(i, jj) * tempb
                            winvupb(indel, jj) = winvupb(indel, jj) + tempb1 * elocb(1)
                            winvupb(indel + 1, jj) = winvupb(indel + 1, jj) + tempb1 * elocb(2)
                        endif
                    END DO
                END DO
                DO jj = istart, indt
                    DO i = 1, neldo
                        indel = 2 * i - 1
                        tempb0 = -tabpip(i + nelup, jj) * elocb(1)
                        tempb1 = -tabpip(i + nelup, jj) * elocb(2)
                        if(-tmu(i + nelup, jj) * winvdo(indel, jj).gt.0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + (1.d0 + gamma) * winvdo(indel, jj) * tempb0
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + (1.d0 + gamma) * winvdo(indel + 1, jj) * tempb1
                            winvdob(indel, jj) = winvdob(indel, jj) + (1.d0 + gamma) * tmu(i + nelup, jj) * tempb0
                            winvdob(indel + 1, jj) = winvdob(indel + 1, jj) + (1.d0 + gamma) * tmu(i + nelup, jj) * tempb1
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj)&
                                    & - (1.d0 + gamma) * tmu(i + nelup, jj) * winvdo(indel, jj) * elocb(1)&
                                    & - (1.d0 + gamma) * tmu(i + nelup, jj) * winvdo(indel + 1, jj) * elocb(2)
                        elseif(npow.gt.0.d0) then
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + npow*(1.d0 + gamma) * winvdo(indel, jj) * tempb0
                            tmub(i + nelup, jj) = tmub(i + nelup, jj) + npow*(1.d0 + gamma) * winvdo(indel + 1, jj) * tempb1
                            winvdob(indel, jj) = winvdob(indel, jj) + npow*(1.d0 + gamma) * tmu(i + nelup, jj) * tempb0
                            winvdob(indel + 1, jj) = winvdob(indel + 1, jj) + npow*(1.d0 + gamma) * tmu(i + nelup, jj) * tempb1
                            tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj)&
                                    & - npow*(1.d0 + gamma) * tmu(i + nelup, jj) * winvdo(indel, jj) * elocb(1)&
                                    & - npow*(1.d0 + gamma) * tmu(i + nelup, jj) * winvdo(indel + 1, jj) * elocb(2)
                        endif
                    END DO
                    DO i = 1, nelup
                        indel = ipc * (i - 1) + 1
                        tempb = -winvup(indel, jj) * elocb(1) - winvup(indel + 1, jj) * elocb(2)
                        tempb1 = tmu(i, jj) * tabpip(i, jj)
                        if(-tmu(i, jj) * winvup(indel, jj).gt.0) then
                            tmub(i, jj) = tmub(i, jj) + (1.d0 + gamma) * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + (1.d0 + gamma) * tmu(i, jj) * tempb
                            winvupb(indel, jj) = winvupb(indel, jj) - (1.d0 + gamma) * tempb1 * elocb(1)
                            winvupb(indel + 1, jj) = winvupb(indel + 1, jj) - (1.d0 + gamma) * tempb1 * elocb(2)
                        elseif(npow.gt.0.d0) then
                            tmub(i, jj) = tmub(i, jj) + npow*(1.d0 + gamma) * tabpip(i, jj) * tempb
                            tabpipb(i, jj) = tabpipb(i, jj) + npow*(1.d0 + gamma) * tmu(i, jj) * tempb
                            winvupb(indel, jj) = winvupb(indel, jj) - npow*(1.d0 + gamma) * tempb1 * elocb(1)
                            winvupb(indel + 1, jj) = winvupb(indel + 1, jj) - npow*(1.d0 + gamma) * tempb1 * elocb(2)
                        endif
                    END DO
                END DO
            endif
        endif
        IF (ncore .GT. 0.and..not.lrdmc_deru) THEN
            ! to compute
            if(ipc.eq.1) then
                DO jj = istart, indt
                    DO i = 1, neldo
                        tempb0 = -(tabpip(i + nelup, jj) * elocb(1))
                        tmub(i + nelup, jj) = tmub(i + nelup, jj) + winvdo(i, jj) * tempb0
                        winvdob(i, jj) = winvdob(i, jj) + tmu(i + nelup, jj) * tempb0
                        tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj) - tmu(i + nelup, jj)&
                                & * winvdo(i, jj) * elocb(1)
                    END DO
                    DO i = 1, nelup
                        tempb = -(winvup(i, jj) * elocb(1))
                        tmub(i, jj) = tmub(i, jj) + tabpip(i, jj) * tempb
                        tabpipb(i, jj) = tabpipb(i, jj) + tmu(i, jj) * tempb
                        winvupb(i, jj) = winvupb(i, jj) - tmu(i, jj) * tabpip(i, jj) * &
                                &            elocb(1)
                    END DO
                END DO
            else
                DO jj = istart, indt
                    DO i = 1, neldo
                        indel = 2 * i - 1
                        tempb0 = -tabpip(i + nelup, jj) * elocb(1)
                        tempb1 = -tabpip(i + nelup, jj) * elocb(2)
                        tmub(i + nelup, jj) = tmub(i + nelup, jj) + winvdo(indel, jj) * tempb0
                        tmub(i + nelup, jj) = tmub(i + nelup, jj) + winvdo(indel + 1, jj) * tempb1
                        winvdob(indel, jj) = winvdob(indel, jj) + tmu(i + nelup, jj) * tempb0
                        winvdob(indel + 1, jj) = winvdob(indel + 1, jj) + tmu(i + nelup, jj) * tempb1
                        tabpipb(i + nelup, jj) = tabpipb(i + nelup, jj)&
                                & - tmu(i + nelup, jj) * winvdo(indel, jj) * elocb(1)&
                                & - tmu(i + nelup, jj) * winvdo(indel + 1, jj) * elocb(2)
                    END DO
                    DO i = 1, nelup
                        indel = ipc * (i - 1) + 1
                        tempb = -winvup(indel, jj) * elocb(1) - winvup(indel + 1, jj) * elocb(2)
                        tmub(i, jj) = tmub(i, jj) + tabpip(i, jj) * tempb
                        tabpipb(i, jj) = tabpipb(i, jj) + tmu(i, jj) * tempb
                        tempb1 = tmu(i, jj) * tabpip(i, jj)
                        winvupb(indel, jj) = winvupb(indel, jj) - tempb1 * elocb(1)
                        winvupb(indel + 1, jj) = winvupb(indel + 1, jj) - tempb1 * elocb(2)
                    END DO
                END DO
            endif

        END IF
        vpotb = elocb(1)
        CALL SUBENER_B(indt, nelup, neldo, winvup, winvupb, winvdo, winvdob&
                &, tabpip, tabpipb, eloc, elocb)
    END SUBROUTINE TASK11_B
    !  Differentiation of task3 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: psip rion iond
    !   of linear combination of output variables: psip rion iond
    SUBROUTINE TASK3_B(rion, rionb, iond_cart, iond_cartb, cellscaleb, s2rb)
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: rion(3, nion)
        REAL*8 :: rionb(3, nion), cellscaleb(3), s2rb(3, 3)
        REAL*8 :: iond_cart(3,nion, nion)
        REAL*8 :: iond_cartb(3,nion, nion)
        CALL EVAL_IOND_B(iond_cart, iond_cartb, rion, rionb, nion, lbox, cellscaleb, s2rb)
    END SUBROUTINE TASK3_B
    !  Differentiation of task6 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: zeta kelind rion
    !                iond
    !   of linear combination of output variables: zeta lbox kelind
    !                vpot rion
    SUBROUTINE TASK6_B(kelind, kelindb, rion, rionb, iond_cart, iond_cartb, vpot, &
            &    vpotb, cellscaleb, s2rb)
        IMPLICIT NONE
  REAL*8, INTENT(IN) :: kelind(3,nel), rion(3,nion), iond_cart(3,nion,nion)
        REAL*8 :: kelindb(3, nel), rionb(3, nion), iond_cartb(3,nion, nion)
        REAL*8 :: vpot
        REAL*8 :: vpotb, cellscaleb(3), s2rb(3, 3)
        !   evaluate classical potential energy
        !   input kelind(3,nel), (NB the mesh is not used)
        !   input rion(3,nion)
        !   input iond(nion,nion)
        !   output vpot (classical Coulomb energy).
        ! compute the potential energy
        CALL UPVPOTDIAG_B(kelind, kelindb, nel, zeta, rion, rionb, iond,&
                &                iond_cart, iond_cartb, vpot, vpotb, nion, oldkappa, lbox, &
                &                vpotreg, cutreg, costz, costz3, cellscaleb, s2rb)
    END SUBROUTINE TASK6_B
    !  Differentiation of task7 in reverse (adjoint) mode:
    !   gradient, with respect to input variables: lbox kelind vpot
    !                rion
    !   of linear combination of output variables: lbox vpot rion
    SUBROUTINE TASK7_B(kelind, kelindb, rion, rionb, vpseudolocal&
            &, vpseudolocalb, vpot, vpotb, cellscaleb, recipb, omegab)
        IMPLICIT NONE
        REAL*8, INTENT(IN) :: kelind(3, nel), rion(3, nion), vpseudolocal
        REAL*8 :: kelindb(3, nel), rionb(3, nion), vpseudolocalb, cellscaleb(3)
        REAL*8 :: vpot
        REAL*8 :: vpotb
        real*8 :: recipb(3, 3), omegab
        !!********* Add Ewald Sums *******************
        ! if PBC on correct vpot for Ewald contribution.
        !  input rion(3,nion), kelind(3,nel)
        !  output vpot, the rest not used.
        IF(ncore.gt.0) vpseudolocalb = vpseudolocalb + 2.d0 * vpotb

        IF (lbox .GT. 0.d0) THEN
            ukwaldb = vpotb

            vpotb = vpotb
            CALL EWALDSUM_B(kelind, kelindb, rion, rionb, ukwald, ukwaldb, &
                    &                cellscale, cellscaleb, recipb, omegab, walker)
        END IF

    END SUBROUTINE TASK7_B
END SUBROUTINE COMPUTE_ELOC_LOGPSI_B
subroutine conjvec(n, v, ldv)
    implicit none
    integer n, i, j, ldv
    complex*16 v(ldv)
    do i = 1, n
        v(i) = dconjg(v(i))
    enddo
    return
end
subroutine conjmat(n, m, a, lda)
    implicit none
    integer n, m, i, j, lda
    complex*16 a(lda, *)
    do j = 1, m
        do i = 1, n
            a(i, j) = dconjg(a(i, j))
        enddo
    enddo
    return
end
subroutine symmetrize_(ipc, ipf, yes_hermite, nelorb, nelorb_at, detmat)
    use allio, only : pfaffup
    implicit none
    integer i, j, ipc, ipf, nelorb, nelorb_at, ndim
    real*8 detmat(ipc * ipf * nelorb, nelorb), detsav1,detsav2
    logical yes_hermite
    if(ipc.eq.1) then
        if(ipf.eq.1) then
            do i = 1, nelorb
                do j =  1, nelorb
                    if(j.gt.i) then
                    detsav1 = detmat(i, j) + detmat(j, i)
                    detmat(i, j) = detsav1
                    detmat(j, i) = detsav1
                    endif
                enddo
            enddo
        else
            ndim = nelorb_at / 2
            do i = 1, 2 * nelorb
                do j = 1, 2 * nelorb
                    if(j.gt.i.and.j.le.nelorb_at.and.i.le.nelorb_at) then
                        if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                            !          amat(i+ndim, j+ndim)=value
                            !          amat(j+ndim, i+ndim)=-value
                            detsav1 = detmat(i, j) + detmat(i + ndim, j + ndim)
                            detmat(i, j) = detsav1
                            detmat(j, i) = -detsav1
                            detmat(i + ndim, j + ndim) = detsav1
                            detmat(j + ndim, i + ndim) = -detsav1
                        elseif(j.gt.ndim.and.i.le.ndim) then
                            !          amat(j-ndim, i+ndim)=value
                            !          amat(i+ndim, j-ndim)=-value
                            detsav1 = detmat(i, j) + detmat(j - ndim, i + ndim)
                            detmat(i, j) = detsav1
                            detmat(j, i) = -detsav1
                            detmat(j - ndim, i + ndim) = detsav1
                            detmat(i + ndim, j - ndim) = -detsav1
                        end if
                    end if
                enddo
            enddo
        endif
    else
        if(ipf.eq.2) then
            ndim = nelorb_at / 2
            do i = 1, 2 * nelorb
                do j = i, 2 * nelorb
                    if(j.gt.i.and.i.le.nelorb_at.and.j.le.nelorb_at) then
                        if(yes_hermite) then
                            if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                                !             amat(i+ndim, j+ndim)=conjg(value(1))
                                !             amat(j+ndim, i+ndim)=-conjg(value(1))
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (i + ndim) - 1, j + ndim)
                                detsav2 = detmat(2 * i, j) - detmat(2 * (i + ndim), j + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (i + ndim) - 1, j + ndim) = detsav1
                                detmat(2 * (i + ndim), j + ndim) = -detsav2
                                detmat(2 * (j + ndim) - 1, i + ndim) = -detsav1
                                detmat(2 * (j + ndim), i + ndim) = detsav2
                            elseif(j.gt.ndim.and.i.le.ndim) then
                                !             amat(j-ndim, i+ndim)=conjg(value(1))
                                !             amat(i+ndim, j-ndim)=-conjg(value(1))
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (j - ndim) - 1, i + ndim)
                                detsav2 = detmat(2 * i, j) - detmat(2 * (j - ndim), i + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (j - ndim) - 1, i + ndim) = detsav1
                                detmat(2 * (j - ndim), i + ndim) = -detsav2
                                detmat(2 * (i + ndim) - 1, j - ndim) = -detsav1
                                detmat(2 * (i + ndim), j - ndim) = detsav2
                            endif
                        else
                            if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                                !              amat(i+ndimh, j+ndimh)=value(1)
                                !              amat(j+ndimh, i+ndimh)=-value(1)
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (i + ndim) - 1, j + ndim)
                                detsav2 = detmat(2 * i, j) + detmat(2 * (i + ndim), j + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (i + ndim) - 1, j + ndim) = detsav1
                                detmat(2 * (i + ndim), j + ndim) = detsav2
                                detmat(2 * (j + ndim) - 1, i + ndim) = -detsav1
                                detmat(2 * (j + ndim), i + ndim) = -detsav2
                            elseif(j.gt.ndim.and.i.le.ndim) then
                                !             amat(j-ndimh, i+ndimh)=value(1)
                                !             amat(i+ndimh, j-ndimh)=-value(1)
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (j - ndim) - 1, i + ndim)
                                detsav2 = detmat(2 * i, j) + detmat(2 * (j - ndim), i + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (j - ndim) - 1, i + ndim) = detsav1
                                detmat(2 * (j - ndim), i + ndim) = detsav2
                                detmat(2 * (i + ndim) - 1, j - ndim) = -detsav1
                                detmat(2 * (i + ndim), j - ndim) = -detsav2
                            endif
                        endif
                    endif
                enddo
            enddo
        else
            do i = 1, nelorb
                do j =  1, nelorb
                  if(j.gt.i) then
                    detsav1 = (detmat(2 * i - 1, j) + detmat(2 * j - 1, i))
                    detmat(2 * i - 1, j) = detsav1
                    detmat(2 * j - 1, i) = detsav1
                    if(i.le.nelorb_at.and.j.le.nelorb_at) then
                        if(yes_hermite) then
                            detsav2 = (detmat(2 * i, j) - detmat(2 * j, i))
                            detmat(2 * i, j) = detsav2
                            detmat(2 * j, i) = -detsav2
                        else
                            detsav2 = (detmat(2 * i, j) + detmat(2 * j, i))
                            detmat(2 * i, j) = detsav2
                            detmat(2 * j, i) = detsav2
                        endif
                    endif
                   endif
                enddo
            enddo
        endif
    endif
    return
end
subroutine symmetrize(ipc, ipf, yes_hermite, nelorb, nelorb_at, detmat)
    use allio, only : pfaffup
    implicit none
    integer i, j, ipc, ipf, nelorb, nelorb_at, ndim
    real*8 detmat(ipc * ipf * nelorb, nelorb), detsav1,detsav2
    logical yes_hermite
    if(ipc.eq.1) then
        if(ipf.eq.1) then
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1)
#endif
            do i = 1, nelorb
                do j =  1, nelorb
                    if(j.gt.i) then
                    detsav1 = detmat(i, j) + detmat(j, i)
                    detmat(i, j) = detsav1
                    detmat(j, i) = detsav1
                    endif
                enddo
            enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
        else
            ndim = nelorb_at / 2
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1)
#endif
            do i = 1, 2 * nelorb
                do j = 1, 2 * nelorb
                    if(j.gt.i.and.j.le.nelorb_at.and.i.le.nelorb_at) then
                        if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                            !          amat(i+ndim, j+ndim)=value
                            !          amat(j+ndim, i+ndim)=-value
                            detsav1 = detmat(i, j) + detmat(i + ndim, j + ndim)
                            detmat(i, j) = detsav1
                            detmat(j, i) = -detsav1
                            detmat(i + ndim, j + ndim) = detsav1
                            detmat(j + ndim, i + ndim) = -detsav1
                        elseif(j.gt.ndim.and.i.le.ndim) then
                            !          amat(j-ndim, i+ndim)=value
                            !          amat(i+ndim, j-ndim)=-value
                            detsav1 = detmat(i, j) + detmat(j - ndim, i + ndim)
                            detmat(i, j) = detsav1
                            detmat(j, i) = -detsav1
                            detmat(j - ndim, i + ndim) = detsav1
                            detmat(i + ndim, j - ndim) = -detsav1
                        end if
                    end if
                enddo
            enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
        endif
    else
        if(ipf.eq.2) then
            ndim = nelorb_at / 2
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1,detsav2)
#endif
            do i = 1, 2 * nelorb
                do j = 1, 2 * nelorb
                    if(j.gt.i.and.i.le.nelorb_at.and.j.le.nelorb_at) then
                        if(yes_hermite) then
                            if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                                !             amat(i+ndim, j+ndim)=conjg(value(1))
                                !             amat(j+ndim, i+ndim)=-conjg(value(1))
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (i + ndim) - 1, j + ndim)
                                detsav2 = detmat(2 * i, j) - detmat(2 * (i + ndim), j + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (i + ndim) - 1, j + ndim) = detsav1
                                detmat(2 * (i + ndim), j + ndim) = -detsav2
                                detmat(2 * (j + ndim) - 1, i + ndim) = -detsav1
                                detmat(2 * (j + ndim), i + ndim) = detsav2
                            elseif(j.gt.ndim.and.i.le.ndim) then
                                !             amat(j-ndim, i+ndim)=conjg(value(1))
                                !             amat(i+ndim, j-ndim)=-conjg(value(1))
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (j - ndim) - 1, i + ndim)
                                detsav2 = detmat(2 * i, j) - detmat(2 * (j - ndim), i + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (j - ndim) - 1, i + ndim) = detsav1
                                detmat(2 * (j - ndim), i + ndim) = -detsav2
                                detmat(2 * (i + ndim) - 1, j - ndim) = -detsav1
                                detmat(2 * (i + ndim), j - ndim) = detsav2
                            endif
                        else
                            if (j.le.ndim.and.i.le.ndim.and..not.pfaffup) then
                                !              amat(i+ndimh, j+ndimh)=value(1)
                                !              amat(j+ndimh, i+ndimh)=-value(1)
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (i + ndim) - 1, j + ndim)
                                detsav2 = detmat(2 * i, j) + detmat(2 * (i + ndim), j + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (i + ndim) - 1, j + ndim) = detsav1
                                detmat(2 * (i + ndim), j + ndim) = detsav2
                                detmat(2 * (j + ndim) - 1, i + ndim) = -detsav1
                                detmat(2 * (j + ndim), i + ndim) = -detsav2
                            elseif(j.gt.ndim.and.i.le.ndim) then
                                !             amat(j-ndimh, i+ndimh)=value(1)
                                !             amat(i+ndimh, j-ndimh)=-value(1)
                                detsav1 = detmat(2 * i - 1, j) + detmat(2 * (j - ndim) - 1, i + ndim)
                                detsav2 = detmat(2 * i, j) + detmat(2 * (j - ndim), i + ndim)
                                detmat(2 * i - 1, j) = detsav1
                                detmat(2 * i, j) = detsav2
                                detmat(2 * j - 1, i) = -detsav1
                                detmat(2 * j, i) = -detsav2
                                detmat(2 * (j - ndim) - 1, i + ndim) = detsav1
                                detmat(2 * (j - ndim), i + ndim) = detsav2
                                detmat(2 * (i + ndim) - 1, j - ndim) = -detsav1
                                detmat(2 * (i + ndim), j - ndim) = -detsav2
                            endif
                        endif
                    endif
                enddo
            enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
        else
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1,detsav2)
#endif
            do i = 1, nelorb
                do j =  1, nelorb
                  if(j.gt.i) then
                    detsav1 = (detmat(2 * i - 1, j) + detmat(2 * j - 1, i))
                    detmat(2 * i - 1, j) = detsav1
                    detmat(2 * j - 1, i) = detsav1
                    if(i.le.nelorb_at.and.j.le.nelorb_at) then
                        if(yes_hermite) then
                            detsav2 = (detmat(2 * i, j) - detmat(2 * j, i))
                            detmat(2 * i, j) = detsav2
                            detmat(2 * j, i) = -detsav2
                        else
                            detsav2 = (detmat(2 * i, j) + detmat(2 * j, i))
                            detmat(2 * i, j) = detsav2
                            detmat(2 * j, i) = detsav2
                        endif
                    endif
                   endif
                enddo
            enddo
#ifdef _OFFLOAD
!$omp end  target teams distribute parallel do 
#endif
        endif
    endif
    return
end

subroutine symmetrizepfaff(ipc, nelorb, detmat)
    implicit none
    integer i, j, ipc, nelorb
    real*8 detmat(ipc * nelorb, nelorb), detsav1,detsav2
    if(ipc.eq.1) then
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1)
#endif
        do i = 1, nelorb
            do j = 1 , nelorb
               if(j.gt.i) then
                detsav1 = detmat(i, j) - detmat(j, i)
                detmat(i, j) = detsav1
                detmat(j, i) = -detsav1
               elseif(i.eq.j) then
                detmat(i, i) = 0.d0
               endif
            enddo
        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
    else
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2) private(detsav1,detsav2)
#endif
        do i = 1, nelorb
            do j = 1, nelorb
              if(j.gt.i)  then
                detsav1 = (detmat(2 * i - 1, j) - detmat(2 * j - 1, i))
                detmat(2 * i - 1, j) = detsav1
                detmat(2 * j - 1, i) = -detsav1
                detsav2 = (detmat(2 * i, j) - detmat(2 * j, i))
                detmat(2 * i, j) = detsav2
                detmat(2 * j, i) = -detsav2
              elseif(j.eq.i) then
                detmat(2 * i - 1, i) = 0.d0
                detmat(2 * i, i) = 0.d0
              endif
            enddo
        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
    endif
    return
end

subroutine update_eagp_complex(yes_transp, costpsic, ndiff, nelup_mat&
        &, ainv, eagp_pfaffb)
    implicit none
    logical yes_transp
    integer ndiff, nelup_mat, k, j
    complex*16 ainv(nelup_mat, nelup_mat), eagp_pfaffb(ndiff, ndiff), costpsic
    if(yes_transp) then
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
        do j = 1, ndiff
            do k = 1, ndiff
                eagp_pfaffb(k, j) = eagp_pfaffb(k, j) + costpsic * ainv(nelup_mat - ndiff + j, nelup_mat - ndiff + k)
                ainv(nelup_mat - ndiff + j, nelup_mat - ndiff + k) = (0.d0, 0.d0)
            enddo
        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
    else
#ifdef _OFFLOAD
!$omp target teams distribute parallel do collapse(2)
#endif
        do j = 1, ndiff
            do k = 1, ndiff
                eagp_pfaffb(k, j) = eagp_pfaffb(k, j) + costpsic * ainv(nelup_mat - ndiff + k, nelup_mat - ndiff + j)
                ainv(nelup_mat - ndiff + k, nelup_mat - ndiff + j) = (0.d0, 0.d0)
            enddo
        enddo
#ifdef _OFFLOAD
!$omp end target teams distribute parallel do 
#endif
    endif
    return
end


!TL off
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.2 (r3024) - 06/17/2009 13:03
!  
!  Differentiation of up2bodypsi in reverse (adjoint) mode:
!   gradient, with respect to input variables: rion kel lbox
!   of linear combination of output variables: rion kel psiln
SUBROUTINE UP2BODYPSI_B(nel, nelup, psiln, psilnb, kel, kelb, vj&
        &, vjb, iesdr, rion, rionb, nion, costz, costz3, lbox, niesd, cellscaleb, metricb, car2cryb)
    USE CELL, only : cellscale, cellpi, metric, CartesianToCrystal, car2cry&
            &, CartesianToCrystal_b, map
    USE CONSTANTS
    USE ALLIO, only : pointvj, n_body_on, norm_metric
    IMPLICIT NONE
    INTEGER :: nel, nelup, iesd, iesdr, k, j1, j2, ispin, nion, &
            &  IESDR2IESD, niesd
    REAL*8 :: kel(3, *), psiln
    REAL*8 :: kelb(3, nel), psilnb
    REAL*8 :: vj(*),vjb(max(niesd,1)),rc(3),rion(3, *),costz(*),costz3(*)&
            &,costz0,JASTROW_EI,JASTROW_EE,r0,cellscaleb(3),rc0(3),rc0b(3)&
            &,rc_sav(3),rccos(3)
    REAL*8 :: rcb(3), rionb(3, nion), costz0b, r0b, jastrow_eeb, jastrow_eib
    real*8 metricb(3, 3), car2cryb(3, 3), rc_before(3), rc0_before(3), aux0
    LOGICAL :: iesspin
    REAL*8 :: lbox
    EXTERNAL IESDR2IESD, IESDR1IESD
    REAL*8 :: result1
    REAL*8 :: result1b
    INTEGER :: branch
    INTEGER :: ad_from
    REAL*8 :: temp0(3)
    INTRINSIC DSIN
    REAL*8 :: temp0b(3)
    INTRINSIC SUM
    INTRINSIC DSQRT
    REAL*8 :: temp(3)
    iesd = IESDR2IESD(iesdr)
    !     iesd=iesdr
    !     if(iesdr.eq.-5) iesd=1
    !     if(iesdr.eq.-6) iesd=4
    !     if(iesdr.eq.-7) iesd=4
    IF (iesdr .EQ. -7 .OR. iesd .EQ. 2 .OR. iesd .LT. 0) THEN
        iesspin = .true.
    ELSE
        iesspin = .false.
    END IF

!$omp parallel do  default(shared) private(j1,j2,k,ispin,rc,rc_before,rc_sav&
!$omp& ,rcb,rc0,rc0b,rc0_before,r0,r0b,jastrow_eeb,jastrow_eib) reduction(+:kelb,rionb,cellscaleb,car2cryb,metricb,vjb)
    do j1 = 1, nel !do for the first particle
        !        costz0=0.d0
        ! The direct loop is useless in this case
        !         do j2=j1+1,nel
        !           if(iesspin) then
        !            if((j1.le.nelup.and.j2.le.nelup).or.(j1.gt.nelup.and.j2.gt.nelup))
        !then
        !                        ! parallel spins
        !               ispin=1
        !            else
        !               ispin=-1
        !            endif
        !           else
        !           ispin=-1
        !           endif
        !!************ PERIODIC WORLD ***********
        !
        !            costz0=costz0+jastrow_ee(rc,vj,iesd,ispin)
        !         enddo


        !         reverse loop
        do j2 = j1 + 1, nel
            if(iesspin) then
                if((j1.le.nelup.and.j2.le.nelup).or.(j1.gt.nelup.and.j2.gt.nelup)) then ! parallel spins
                    ispin = 1
                else
                    ispin = -1
                endif
            else
                ispin = -1
            endif

            rc(:) = kel(:, j1) - kel(:, j2)
            !************ PERIODIC WORLD ***********
            if(LBox.gt.0.d0) then
                rc_before = rc
!               call CartesianToCrystal(rc, 1)
                rc(:)=car2cry(:,1)*rc(1)+car2cry(:,2)*rc(2)+car2cry(:,3)*rc(3)
                rc0(1:3) = rc(1:3)
                do k = 1, 3
                    rc(k) = map(rc0(k), cellscale(k))
                enddo
                rc_sav = rc
            endif
            rcb = 0.d0

            jastrow_eeb = psilnb
            call jastrow_ee_b(rc, rcb, vj, vjb, iesd, ispin, jastrow_eeb, metricb)

            if(LBox.gt.0.d0) then
                !       rccos(:)=dcos(rc0(:))
                !      cellscaleb(1:3)=cellscaleb(1:3)+rcb(1:3)/cellscale(1:3)&
                !     *(rc_sav(1:3)-rc0(1:3)*rccos(1:3)*cellpi(1:3))
                !       rcb(:)=rcb(:)*rccos(:)
                rc0b = 0.d0
                do k = 1, 3
                    call map_b(rc0(k), rc0b(k), cellscale(k), cellscaleb(k), rcb(k))
                    rcb(k) = rc0b(k)
                enddo
                !      rccos(:)=dcos(rc0(:)/cellpi(:))
                !      cellscaleb(1:3)=cellscaleb(1:3)+rcb(1:3)/cellscale(1:3)&
                !     *(rc_sav(1:3)-rc0(1:3)*rccos(1:3))
                !       rcb(:)=rcb(:)*rccos(:)
                call CartesianToCrystal_b(rc_before, rcb, car2cryb, 1)
            endif

            kelb(:, j1) = kelb(:, j1) + rcb(:)

            kelb(:, j2) = kelb(:, j2) - rcb(:)

            !************ PERIODIC WORLD ***********

        enddo

        if(n_body_on.ne.0) then

            do j2 = 1, nion
                if(LBox.gt.0.d0) then
                    rc0(1:3) = kel(1:3, j1) - rion(1:3, j2)
                    rc0_before(:) = rc0(:)
!                   call CartesianToCrystal(rc0, 1)
  rc0(:)=car2cry(:,1)*rc0(1)+car2cry(:,2)*rc0(2)+car2cry(:,3)*rc0(3)
                    do k = 1, 3
                        rc(k) = costz(j2) * map(rc0(k), cellscale(k))
                    enddo
                    rc_sav = rc
                    r0 = norm_metric(rc, metric)
                else
                    rc(:) = costz(j2) * (kel(:, j1) - rion(:, j2))
                    r0 = dsqrt(sum(rc(:)**2))
                endif

                r0b = 0.d0

                jastrow_eib = -psilnb * costz3(j2)

                call jastrow_ei_b(r0, r0b, vj(pointvj(1, j2))&
                        &, vjb(pointvj(1, j2)), pointvj(2, j2), jastrow_eib)

                if(r0.gt.1d-9) then
                    if(Lbox.gt.0.d0) then
                        rcb = 0.d0
                        call norm_metric_b(rc, rcb, metric, metricb, r0b)
                    else
                        rcb(:) = rc(:) / r0 * r0b
                    endif
                else
                    rcb = 0.d0
                endif

                if(Lbox.gt.0) then
                    !  reverse of
                    !         call CartesianToCrystal(rc0,1)
                    !         do k=1,3
                    !         rc(k)=map(rc0(k),cellscale(k))
                    !         enddo
                    !         rc(:)=rc(:)*costz(j2)
                    do k = 1, 3
                        rc0b(k) = 0.d0
                        rcb(k) = rcb(k) * costz(j2)
                        call map_b(rc0(k), rc0b(k), cellscale(k), cellscaleb(k), rcb(k))
                    enddo
                    call CartesianToCrystal_b(rc0_before, rc0b, car2cryb, 1)
                    !  reverse of     rc0(1:3)=kel(1:3,j1)-rion(1:3,j2)
                    kelb(:, j1) = kelb(:, j1) + rc0b(:)
                    rionb(:, j2) = rionb(:, j2) - rc0b(:)
                else
                    kelb(:, j1) = kelb(:, j1) + costz(j2) * rcb(:)
                    rionb(:, j2) = rionb(:, j2) - costz(j2) * rcb(:)
                endif

            enddo

        endif

    enddo
!$omp end parallel do
END SUBROUTINE UP2BODYPSI_B
subroutine norm_metric_b(rc, rcb, metric, metricb, r0b)
    use allio, only: norm_metric
    implicit none
    integer i, j
    real*8 rc(3), rcb(3), metric(3, 3), metricb(3, 3), r0, r0b
    r0 = norm_metric(rc, metric)
    do i = 1, 3
        metricb(:, i) = metricb(:, i) + 0.5d0 * r0b / r0 * rc(:) * rc(i)
        rcb(i) = rcb(i) + r0b * sum(metric(:, i) * rc(:)) / r0
    enddo
    r0b = 0.d0
    return
end

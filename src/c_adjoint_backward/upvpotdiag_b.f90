!TL off
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.2 (r3024) - 06/17/2009 13:03
!  
!  Differentiation of upvpotdiag in reverse (adjoint) mode:
!   gradient, with respect to input variables: rion iond rkel zeta
!   of linear combination of output variables: vpot rion rkel zeta
!                lbox
SUBROUTINE UPVPOTDIAG_B(rkel, rkelb, nel, zeta, rion, rionb, iond,iond_cart&
        &, iond_cartb, vpot, vpotb, nion, kappa, lbox, vpotreg, cutreg, costz&
        &, costz3, cellscaleb, s2rb)

    ! by E. Coccia (28/1/11): external forces
    use ext_forces, only : forcext, forcext_el, force_vdw, mm_f_theta, mm_f_dihed, mm_f_impr
    use extpot, only : ext_pot, link_atom, mm_restr
    use van_der_waals, only : vdw
    ! by E. Coccia (7/12/11): MM restraint forces
    use cl_restr, only : restr_f_bond, restr_f_angle, restr_f_dihe, restr_f_dimp
    use dielectric
    use cell, only: dist_shift,distreg_shift,neigh,x_neigh
    IMPLICIT NONE
    INTEGER :: nel, i, j, k,ii, nion
    integer*8 maxll,ll
    REAL*8 :: rkel(3, nel)
    REAL*8 :: rkelb(3, nel)
    REAL*8 :: zeta(nion), vpot, NGIVEJ, rion(3, nion), iond_cart(3,nion, nion), cost&
            &, tmp, kappa, lbox, pot_ee, pot_ea, pot_aa, MAX, costz(*), &
            &  distb, vpotreg, potreg_ea, costz3(*), cutreg, distbreg
    REAL*8 :: vpotb, rionb(3, nion),iond(nion,nion),  iond_cartb(3,nion, nion)&
            &, costb, tmpb, pot_eeb, pot_eab, pot_aab, distbb, cellscaleb(3)&
            &, s2rb(3, 3)
    real*8 derfc
    EXTERNAL NGIVEJ
    REAL*8 :: result1,iondb,x_shift(3),x_shiftb(3)
    REAL*8 :: result1b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    INTEGER :: ad_from
    INTEGER :: ad_from0
    INTEGER :: branch
    INTEGER :: ad_from1
    INTEGER :: ad_from2
    REAL*8 :: temp0
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: temp0b
    REAL*8 :: tempb
    REAL*8 :: temp
    REAL*8 :: max1
    pot_eeb = vpotb
    pot_eab = vpotb
    pot_aab = vpotb
    iondb=0.d0
    IF (Lbox.le.0.d0) THEN

!$omp parallel do default(shared) private(i,j,tempb0,iondb) reduction(+:iond_cartb)
        DO i = 1, nion
            DO j = i + 1, nion
!               tempb0 = 2.d0 * pot_aab / iond(i, j)
!               if(zeta(i) * zeta(j).ne.0.d0)     iondb(i, j) = &
!                       &iondb(i, j) - zeta(i) * zeta(j) * tempb0 / iond(i, j)
!           reverse of 
!           temp0=veps(iond(i,j))
!           pot_aa=pot_aa+2.d0*zeta(i)*zeta(j)*temp0
            tempb0=2.d0*pot_aab*zeta(i)*zeta(j)
            if(tempb0.ne.0.d0) then 
            call veps_b(iond(i,j),iondb,tempb0)
!           reverse  of iond=sqrt(iond_cart**2)
           iond_cartb(:,i,j)=iond_cartb(:,i,j)+iondb*iond_cart(:,i,j)/iond(i,j)
            iondb=0.d0
            endif
            END DO
        END DO

!$omp parallel do default(shared) private(i,j,result1,result1b,tempb0) reduction(+:rkelb)
        DO i = 1, nel
            DO j = i + 1, nel
                result1 = NGIVEJ(rkel(1, i), rkel(1, j), lbox)
!               result1b = -(2.d0 * pot_eeb / result1**2)
!               reverse of 
!               temp0=veps(result1)
!               pot_ee=pot_ee+2.d0*temp0 
                result1b=0.d0
                tempb0=2.d0*pot_eeb
                call veps_b(result1,result1b,tempb0)

                CALL NGIVEJ_B(rkel(1, i), rkelb(1, i), rkel(1, j), rkelb(1, j), &
                        &                lbox, result1b, cellscaleb, s2rb)
            END DO
        END DO
!$omp parallel do default(shared) private(i,k,distb,distbb,tempb) reduction(+:rkelb,rionb)
        DO k = 1, nion
            DO i = 1, nel
                distb = NGIVEJ(rion(1, k), rkel(1, i), lbox)
!               tempb = -(2.d0 * pot_eab / distb)
!               distbb = -(zeta(k) * tempb / distb)
!       reverse of 
!               temp=veps(distb)
!               pot_ea=pot_ea-2.d0*zeta(k)*temp
                tempb =-2.d0*pot_eab*zeta(k)
                distbb=0.d0
                call veps_b(distb,distbb,tempb)
                
                CALL NGIVEJ_B(rion(1, k), rionb(1, k), rkel(1, i), rkelb(1, i), &
                        &                lbox, distbb, cellscaleb, s2rb)
            END DO
        END DO
    ELSE
        distreg_shift(1:neigh)=0.d0
        maxll=nion
        maxll=(maxll*(nion-1))/2
!$omp parallel do default(shared) private(ll,i,j,ii,temp0b,dist_shift,distreg_shift,cost) reduction(+:iond_cartb)
        do ll=1,maxll
        call find_j1j2(nion,ll,i,j)
!       DO i = 1, nion
!           DO j = i + 1, nion
!           reverse of:
!           temp0=rep_erfc(iond(i,j),kappa)
!           pot_aa=pot_aa+2.d0*zeta(i)*zeta(j)*temp0
            temp0b=2.d0*zeta(i)*zeta(j)*pot_aab
          if(temp0b.ne.0.d0) then 
#ifdef _SIMD
!$omp simd
#endif
          do ii=1,neigh
          dist_shift(ii)=dsqrt((iond_cart(1,i,j)+x_neigh(ii,1))**2+(iond_cart(2,i,j)+x_neigh(ii,2))**2+(iond_cart(3,i,j)+x_neigh(ii,3))**2)

          call rep_erfc_b(dist_shift(ii),distreg_shift(ii),kappa,temp0b)
!         reverse of iond=dsqrt(iond_cart**2)
!         iond_cartb(:,i,j)=iond_cartb(:,i,j)+distreg_shift(ii)*iond_cart(:,i,j)/iond(i,j)
          enddo
          cost=sum(distreg_shift(1:neigh))
          iond_cartb(:,i,j)=iond_cartb(:,i,j)+cost*iond_cart(:,i,j)/iond(i,j)
          endif
!               IF(zeta(i) * zeta(j).ne.0.d0) then
!                   temp0 = iond(i, j)
!                   temp = zeta(j) / temp0
!                   temp0b = 2.d0 * temp * pot_aab
!                   arg1 = kappa * iond(i, j)
!                   result1 = DERFC(arg1)
!                   tempb3 = 2.d0 * zeta(i) * result1 * pot_aab / temp0
!                   result1b = zeta(i) * temp0b
!                   arg1b = 0.0_8
!                   CALL DERFC_B(arg1, arg1b, result1b)
!                   iondb(i, j) = iondb(i, j) + kappa * arg1b - temp * tempb3
!               ENDIF
            END DO
!       END DO
        maxll=nel
        maxll=(maxll*(nel-1))/2
!$omp parallel do default(shared) private(ll,i,j,ii,x_shift,x_shiftb,result1b,dist_shift,distreg_shift) reduction(+:rkelb,cellscaleb,s2rb)
        do ll=1,maxll
        call find_j1j2(nel,ll,i,j)
!       DO i = 1, nel
!           DO j = i + 1, nel
!               tmp = NGIVEJ(rkel(1, i), rkel(1, j), lbox)
                call dgivej(rkel(1, i), rkel(1, j), LBox,x_shift)
!               tempb2 = 2.d0 * pot_eeb / tmp
!               result1b = tempb2
!               arg1 = kappa * tmp
!               result1 = DERFC(arg1)
!               arg1b = 0.0_8
!               CALL DERFC_B(arg1, arg1b, result1b)
!               tmpb = kappa * arg1b - result1 * tempb2 / tmp
!               reverse of 
!               tmp=NGIVEJ(rkel(1, i), rkel(1, j), lbox)
!               result1=rep_erfc(tmp,kappa)
!               pot_ee=pot_ee+2.d0*result1
                result1b=2.d0*pot_eeb
                x_shiftb=0.d0
#ifdef _SIMD
!$omp simd
#endif
                do ii=1,neigh
               dist_shift(ii) = max(dsqrt((x_shift(1)+x_neigh(ii,1))**2+&
      & (x_shift(2)+x_neigh(ii,2))**2+(x_shift(3)+x_neigh(ii,3))**2),1d-9)
              call rep_erfc_b(dist_shift(ii),distreg_shift(ii),kappa,result1b)
!           CALL NGIVEJ_B(rkel(1, i), rkelb(1, i), rkel(1, j), rkelb(1, j), &
!          &                lbox, tmpb, cellscaleb, s2rb)
                enddo
             do ii=1,neigh
!         reverse of dist_shift= (as above)
            x_shiftb(:)=x_shiftb(:)+distreg_shift(ii)*(x_shift(:)+x_neigh(ii,:))/dist_shift(ii)
             enddo
           CALL DGIVEJ_B(rkel(1, i), rkelb(1, i), rkel(1, j), rkelb(1, j), &
          &                lbox, x_shiftb, cellscaleb, s2rb)
            END DO
!       END DO
!$omp parallel do default(shared) private(i,k,ii,x_shift,x_shiftb,costb,dist_shift,distreg_shift) reduction(+:rkelb,rionb,cellscaleb,s2rb)
        DO k = 1, nion
!           zreg2 = costz(k) * costz3(k)
!           IF (zreg2 * cutreg .GT. 0) THEN
                DO i = 1, nel
             
                    costb = -(2.d0 * zeta(k) * pot_eab)
                    call dgivej(rion(1, k), rkel(1, i), LBox,x_shift)
             
!                    distb = NGIVEJ(rion(1, k), rkel(1, i), lbox)
!                   arg1 = kappa * distb
!                   result1 = DERFC(arg1)
!                   result1b = costb / distb
!                   arg1b = 0.0_8
!                   CALL DERFC_B(arg1, arg1b, result1b)
!                   distbb = kappa * arg1b - result1 * costb / distb**2
!                   Reverse of
!                   distb=NGIVEJ(rion(1, k), rkel(1, i), lbox)
!                   cost=rep_erfc(distb,kappa)
!                   pot_ea=pot_ea-2.d0*zeta(k)*cost
#ifdef _SIMD
!$omp simd
#endif
                    do ii=1,neigh
                    dist_shift(ii) = max(dsqrt((x_shift(1)+x_neigh(ii,1))**2+&
      & (x_shift(2)+x_neigh(ii,2))**2+(x_shift(3)+x_neigh(ii,3))**2),1d-9)
                  call rep_erfc_b(dist_shift(ii),distreg_shift(ii),kappa,costb)
                    enddo
                    x_shiftb=0.d0
                    do ii=1,neigh
            x_shiftb(:)=x_shiftb(:)+distreg_shift(ii)*(x_shift(:)+x_neigh(ii,:))/dist_shift(ii)
                    enddo

!                    CALL NGIVEJ_B(rion(1, k), rionb(1, k), rkel(1, i), rkelb(1, i)&
!                            &, lbox, distbb, cellscaleb, s2rb)
                    CALL DGIVEJ_B(rion(1, k), rionb(1, k), rkel(1, i), rkelb(1, i)&
                            &, lbox, x_shiftb, cellscaleb, s2rb)
                END DO
!           ELSE
!               DO i = 1, nel
!                   distb = NGIVEJ(rion(1, k), rkel(1, i), lbox)
!                   tempb1 = -(2.d0 * zeta(k) * pot_eab / distb)
!                   result1b = tempb1
!                   arg1 = kappa * distb
!                   result1 = DERFC(arg1)
!                   arg1b = 0.0_8
!                   CALL DERFC_B(arg1, arg1b, result1b)
!                   distbb = kappa * arg1b - result1 * tempb1 / distb
!                   CALL NGIVEJ_B(rion(1, k), rionb(1, k), rkel(1, i), rkelb(1, i)&
!                           &, lbox, distbb, cellscaleb, s2rb)
!               END DO
!           END IF
        END DO
    END IF

    ! by. E. Coccia (28/1/11):
    ! gradients of the external potential
    ! with respect to both the electronic
    ! and nuclear coordinates.
    ! Analytic differentation of the interpolating
    ! polynomial.
    if (ext_pot) then
        ! electronic and nuclear gradients
        call ext_force(nion, rion, zeta, nel, rkel)
        ! electrons
        do i = 1, nel
            rkelb(:, i) = rkelb(:, i) - 2.d0 * vpotb * forcext_el(:, i)
        enddo

        ! nuclei
        do i = 1, nion
            rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * forcext(:, i)
        enddo

        ! by E. Coccia (6/2/11): add the vdw forces acting on the nuclei
        if (vdw) then
            call vdw_force(nion, rion)
            do i = 1, nion
                rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * force_vdw(:, i)
            enddo
        endif

        ! by E. Coccia (10/5/11): forces for the capping atom
        if (link_atom) then
            ! by E. Coccia (17/5/11): QM forces from mm_pot_theta
            call force_angle()
            do i = 1, nion
                rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * mm_f_theta(:, i)
            enddo
            ! by E. Coccia (18/5/11): QM forces from mm_pot_dihed and mm_pot_impr
            call force_dihed()
            do i = 1, nion
                rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * mm_f_dihed(:, i)
            enddo
            call force_improper()
            do i = 1, nion
                rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * mm_f_impr(:, i)
            enddo
        endif
    endif
    ! by E. Coccia (7/12/11): forces for the MM restraints
    if (mm_restr) then
        call rf_bond()
        do i = 1, nion
            rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * restr_f_bond(:, i)
        enddo
        call rf_angle()
        do i = 1, nion
            rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * restr_f_angle(:, i)
        enddo
        call rf_dihe()
        do i = 1, nion
            rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * restr_f_dihe(:, i)
        enddo
        call rf_dimp()
        do i = 1, nion
            rionb(:, i) = rionb(:, i) - 2.d0 * vpotb * restr_f_dimp(:, i)
        enddo
    endif

    VPOTB = 0.d0

    return

END SUBROUTINE UPVPOTDIAG_B
